<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/gitookie/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/gitookie/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/gitookie/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/gitookie/images/logo.svg" color="#222">

<link rel="stylesheet" href="/gitookie/css/main.css">


<link rel="stylesheet" href="/gitookie/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"gitookie.github.io","root":"/gitookie/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="bluemouse&#39;s blog">
<meta property="og:url" content="https://gitookie.github.io/gitookie/index.html">
<meta property="og:site_name" content="bluemouse&#39;s blog">
<meta property="og:locale">
<meta property="article:author" content="bluemouse">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://gitookie.github.io/gitookie/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-Hans'
  };
</script>

  <title>bluemouse's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Basculer la barre de navigation">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/gitookie/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">bluemouse's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/gitookie/" rel="section"><i class="fa fa-home fa-fw"></i>Accueil</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/gitookie/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://gitookie.github.io/gitookie/2025/02/03/chap1.%E7%AC%AC%E4%BA%8C%E8%AE%B2%20%E9%AB%98%E7%B2%BE%E5%BA%A6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/gitookie/images/avatar.gif">
      <meta itemprop="name" content="bluemouse">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bluemouse's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/gitookie/2025/02/03/chap1.%E7%AC%AC%E4%BA%8C%E8%AE%B2%20%E9%AB%98%E7%B2%BE%E5%BA%A6/" class="post-title-link" itemprop="url">Sans titre</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posté le</span>

              <time title="Article créé le: 2025-02-03 18:53:42" itemprop="dateCreated datePublished" datetime="2025-02-03T18:53:42+08:00">2025-02-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Édité le</span>
                <time title="Mis à jour le: 2025-02-02 11:18:10" itemprop="dateModified" datetime="2025-02-02T11:18:10+08:00">2025-02-02</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1-高精度"><a href="#1-高精度" class="headerlink" title="1.高精度"></a>1.高精度</h1><h2 id="1-0-简介"><a href="#1-0-简介" class="headerlink" title="1.0.简介"></a>1.0.简介</h2><h3 id="所谓高精度，在这里指的是大数相关的运算。且不是每一种语言都需要自己实现这种算法。像java和python就不需要（大体上是因为它们已经自带这个功能了）。而算法常用的c-c-则没有这种功能，因此需要自己实现而这门课讲的高精度，主要局限在两个大数相加-相减，以及一个大数乘以一个小数（这里的大数，一般指位数很多的正整数，-len-A-leq-1e6-；小数一般指位数不那么多的正整数，-len-B-leq-9-）"><a href="#所谓高精度，在这里指的是大数相关的运算。且不是每一种语言都需要自己实现这种算法。像java和python就不需要（大体上是因为它们已经自带这个功能了）。而算法常用的c-c-则没有这种功能，因此需要自己实现而这门课讲的高精度，主要局限在两个大数相加-相减，以及一个大数乘以一个小数（这里的大数，一般指位数很多的正整数，-len-A-leq-1e6-；小数一般指位数不那么多的正整数，-len-B-leq-9-）" class="headerlink" title="所谓高精度，在这里指的是大数相关的运算。且不是每一种语言都需要自己实现这种算法。像java和python就不需要（大体上是因为它们已经自带这个功能了）。而算法常用的c&#x2F;c++则没有这种功能，因此需要自己实现而这门课讲的高精度，主要局限在两个大数相加&#x2F;相减，以及一个大数乘以一个小数（这里的大数，一般指位数很多的正整数，$len(A)\leq 1e6$；小数一般指位数不那么多的正整数，$len(B)\leq 9$）"></a>所谓高精度，在这里指的是大数相关的运算。且不是每一种语言都需要自己实现这种算法。像java和python就不需要（大体上是因为它们已经自带这个功能了）。而算法常用的c&#x2F;c++则没有这种功能，因此需要自己实现<br>而这门课讲的高精度，主要局限在两个大数相加&#x2F;相减，以及一个大数乘以一个小数（这里的大数，一般指位数很多的正整数，$len(A)\leq 1e6$；小数一般指位数不那么多的正整数，$len(B)\leq 9$）</h3><h2 id="1-1-高精度加法（两个大数相加）"><a href="#1-1-高精度加法（两个大数相加）" class="headerlink" title="1.1.高精度加法（两个大数相加）"></a>1.1.高精度加法（两个大数相加）</h2><h3 id="1-1-0-简介：这里的难点，或者说需要实现的部分主要是大数的表示，以及大数的运算两部分。因为c-里不能用一个int变量表示出这些大数，一般会考虑把大数的各个位数存到一个vector里。而至于存储的顺序，一般是高位存到后面。举个例子，拿到一个数123456，那么vector中第一个存的是6，第二个存的是5，以此类推。这样做主要是为了方便进位。如果到了最高位，也发生了进位，那么需要再多一位，而因为此时高位在后面，进位的1要存进来，也就相当于vector的末尾需要多插入一个元素。这个是好做到的，就正常存进去就行。而如果是反过来，也就是第一个存1，第二个存2，以此类推，高位在vector的最前面，那么发生进位的时候，就需要在第一个元素前面再插入一个元素，而这就需要把vector中所有元素都往后挪一位，再插入元素1。这就非常麻烦了至于大数的运算，因为有了这个表示方法，就比较容易了。大数加法也是加法，正常来即可。从低到高，一位一位加。需要注意的点就是进位。因此我们可以定义一个变量，指示当前位前面的位是否发生了进位。如果发生了进位，这个变量就是1，否则是0。也因此，初始化的时候就可以初始化为0，毕竟个位相加的时候不会发生进位。"><a href="#1-1-0-简介：这里的难点，或者说需要实现的部分主要是大数的表示，以及大数的运算两部分。因为c-里不能用一个int变量表示出这些大数，一般会考虑把大数的各个位数存到一个vector里。而至于存储的顺序，一般是高位存到后面。举个例子，拿到一个数123456，那么vector中第一个存的是6，第二个存的是5，以此类推。这样做主要是为了方便进位。如果到了最高位，也发生了进位，那么需要再多一位，而因为此时高位在后面，进位的1要存进来，也就相当于vector的末尾需要多插入一个元素。这个是好做到的，就正常存进去就行。而如果是反过来，也就是第一个存1，第二个存2，以此类推，高位在vector的最前面，那么发生进位的时候，就需要在第一个元素前面再插入一个元素，而这就需要把vector中所有元素都往后挪一位，再插入元素1。这就非常麻烦了至于大数的运算，因为有了这个表示方法，就比较容易了。大数加法也是加法，正常来即可。从低到高，一位一位加。需要注意的点就是进位。因此我们可以定义一个变量，指示当前位前面的位是否发生了进位。如果发生了进位，这个变量就是1，否则是0。也因此，初始化的时候就可以初始化为0，毕竟个位相加的时候不会发生进位。" class="headerlink" title="1.1.0.简介：这里的难点，或者说需要实现的部分主要是大数的表示，以及大数的运算两部分。因为c++里不能用一个int变量表示出这些大数，一般会考虑把大数的各个位数存到一个vector里。而至于存储的顺序，一般是高位存到后面。举个例子，拿到一个数123456，那么vector中第一个存的是6，第二个存的是5，以此类推。这样做主要是为了方便进位。如果到了最高位，也发生了进位，那么需要再多一位，而因为此时高位在后面，进位的1要存进来，也就相当于vector的末尾需要多插入一个元素。这个是好做到的，就正常存进去就行。而如果是反过来，也就是第一个存1，第二个存2，以此类推，高位在vector的最前面，那么发生进位的时候，就需要在第一个元素前面再插入一个元素，而这就需要把vector中所有元素都往后挪一位，再插入元素1。这就非常麻烦了至于大数的运算，因为有了这个表示方法，就比较容易了。大数加法也是加法，正常来即可。从低到高，一位一位加。需要注意的点就是进位。因此我们可以定义一个变量，指示当前位前面的位是否发生了进位。如果发生了进位，这个变量就是1，否则是0。也因此，初始化的时候就可以初始化为0，毕竟个位相加的时候不会发生进位。"></a>1.1.0.简介：这里的难点，或者说需要实现的部分主要是大数的表示，以及大数的运算两部分。因为c++里不能用一个int变量表示出这些大数，一般会考虑把大数的各个位数存到一个vector里。而至于存储的顺序，一般是高位存到后面。举个例子，拿到一个数123456，那么vector中第一个存的是6，第二个存的是5，以此类推。这样做主要是为了方便进位。如果到了最高位，也发生了进位，那么需要再多一位，而因为此时高位在后面，进位的1要存进来，也就相当于vector的末尾需要多插入一个元素。这个是好做到的，就正常存进去就行。而如果是反过来，也就是第一个存1，第二个存2，以此类推，高位在vector的最前面，那么发生进位的时候，就需要在第一个元素前面再插入一个元素，而这就需要把vector中所有元素都往后挪一位，再插入元素1。这就非常麻烦了<br>至于大数的运算，因为有了这个表示方法，就比较容易了。大数加法也是加法，正常来即可。从低到高，一位一位加。需要注意的点就是进位。因此我们可以定义一个变量，指示当前位前面的位是否发生了进位。如果发生了进位，这个变量就是1，否则是0。也因此，初始化的时候就可以初始化为0，毕竟个位相加的时候不会发生进位。</h3><h3 id="1-1-1-代码模板"><a href="#1-1-1-代码模板" class="headerlink" title="1.1.1.代码模板"></a>1.1.1.代码模板</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C = A + B, A &gt;= 0, B &gt;= 0</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">add</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, vector&lt;<span class="type">int</span>&gt; &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (A.<span class="built_in">size</span>() &lt; B.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="built_in">add</span>(B, A);</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        t += A[i];</span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.<span class="built_in">size</span>()) t += B[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (t) C.<span class="built_in">push_back</span>(t);</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：yxc</span><br><span class="line">链接：https:<span class="comment">//www.acwing.com/blog/content/277/</span></span><br><span class="line">来源：AcWing</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注释版本代码模板</span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">add</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;a, vector&lt;<span class="type">int</span>&gt; &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;      <span class="comment">// 用于存储结果</span></span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;          <span class="comment">// 用于表示是否进位了</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>() || i &lt; b.<span class="built_in">size</span>(); i++)      <span class="comment">//  从低位到高位，同时注意是否用完了所有位数</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; a.<span class="built_in">size</span>()) t += a[i];</span><br><span class="line">        <span class="keyword">if</span> (i &lt; b.<span class="built_in">size</span>()) t += b[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>(t % <span class="number">10</span>);    <span class="comment">// 存储的结果是对10取模</span></span><br><span class="line">        t /= <span class="number">10</span>;                <span class="comment">// 这个比较重点，是用于判断是否发生了进位。实质上这里就等价于</span></span><br><span class="line">        <span class="comment">// 判断t是否大于10，如果t大于等于10，说明进位了，则t取为1；如果t小于10，说明没进位，</span></span><br><span class="line">        <span class="comment">// 则t取为0</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (t) C.<span class="built_in">push_back</span>(t);      <span class="comment">// 最后别忘了，如果在最高位上进位了，也要加上个1（此时如果</span></span><br><span class="line">                                <span class="comment">// 判断成立，则t必然是1</span></span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string a, b;        <span class="comment">// 因为是高精度，可能位数很多，所以不用int来存储，而是用string来存</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; A, B;</span><br><span class="line">    </span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;      </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = a.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        A.<span class="built_in">push_back</span>(a[i]- <span class="string">&#x27;0&#x27;</span>);     <span class="comment">// 这里要往vector里存数字，然而字符串里是字符，所以要 - &#x27;0&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = b.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        B.<span class="built_in">push_back</span>(b[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C = <span class="built_in">add</span>(A, B);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = C.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, C[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-2-高精度减法（两个大数相减）"><a href="#1-2-高精度减法（两个大数相减）" class="headerlink" title="1.2.高精度减法（两个大数相减）"></a>1.2.高精度减法（两个大数相减）</h2><h3 id="1-2-0-简介：这里的核心问题基本和上面一样，就是大数的表示和减法运算的实现。大同小异吧。只不过这里比上面会多的一个问题就是，较小者减去较大者会减出个负数，这里会影响到输出。一种解决方法是，我们实现的函数就针对第一个输入大于等于第二个输入的情况，而我们在输入之前，就需要判断一下哪个更大。当然，这里因为我们用vector来存储大数，不太能直接进行比较（虽说好像用字符串存储的时候是可以直接比较的？），所以也需要额外写一个函数来实现vector的比较"><a href="#1-2-0-简介：这里的核心问题基本和上面一样，就是大数的表示和减法运算的实现。大同小异吧。只不过这里比上面会多的一个问题就是，较小者减去较大者会减出个负数，这里会影响到输出。一种解决方法是，我们实现的函数就针对第一个输入大于等于第二个输入的情况，而我们在输入之前，就需要判断一下哪个更大。当然，这里因为我们用vector来存储大数，不太能直接进行比较（虽说好像用字符串存储的时候是可以直接比较的？），所以也需要额外写一个函数来实现vector的比较" class="headerlink" title="1.2.0.简介：这里的核心问题基本和上面一样，就是大数的表示和减法运算的实现。大同小异吧。只不过这里比上面会多的一个问题就是，较小者减去较大者会减出个负数，这里会影响到输出。一种解决方法是，我们实现的函数就针对第一个输入大于等于第二个输入的情况，而我们在输入之前，就需要判断一下哪个更大。当然，这里因为我们用vector来存储大数，不太能直接进行比较（虽说好像用字符串存储的时候是可以直接比较的？），所以也需要额外写一个函数来实现vector的比较"></a>1.2.0.简介：这里的核心问题基本和上面一样，就是大数的表示和减法运算的实现。大同小异吧。只不过这里比上面会多的一个问题就是，较小者减去较大者会减出个负数，这里会影响到输出。一种解决方法是，我们实现的函数就针对第一个输入大于等于第二个输入的情况，而我们在输入之前，就需要判断一下哪个更大。当然，这里因为我们用vector来存储大数，不太能直接进行比较（虽说好像用字符串存储的时候是可以直接比较的？），所以也需要额外写一个函数来实现vector的比较</h3><h3 id="1-2-1-代码模板"><a href="#1-2-1-代码模板" class="headerlink" title="1.2.1.代码模板"></a>1.2.1.代码模板</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C = A - B, 满足A &gt;= B, A &gt;= 0, B &gt;= 0</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sub</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, vector&lt;<span class="type">int</span>&gt; &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, t = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        t = A[i] - t;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.<span class="built_in">size</span>()) t -= B[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>((t + <span class="number">10</span>) % <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">if</span> (t &lt; <span class="number">0</span>) t = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> t = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>) C.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：yxc</span><br><span class="line">链接：https:<span class="comment">//www.acwing.com/blog/content/277/</span></span><br><span class="line">来源：AcWing</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, vector&lt;<span class="type">int</span>&gt; &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 这个函数的目的是判断vector A里存储的数是否大于等于vector B里存储的数</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (A.<span class="built_in">size</span>() != B.<span class="built_in">size</span>()) <span class="keyword">return</span> A.<span class="built_in">size</span>() &gt; B.<span class="built_in">size</span>();   <span class="comment">// 如果二者位数不同，则可以直接return</span></span><br><span class="line">    <span class="comment">// 下面是二者位数相同的情况。则要比较大小，就是从高位到低位，逐位比较，一旦出现不同，就可以</span></span><br><span class="line">    <span class="comment">// 直接返回结果</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = A.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (A[i] != B[i]) <span class="keyword">return</span> A[i] &gt; B[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果到了这里，说明二者其实是相等的，也是返回true</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 带注释版本</span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, vector&lt;<span class="type">int</span>&gt; &amp;B)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 这里传入的参数里带上了&amp;，表示这里是一个传递的是一个引用，引用是变量的另一个名字</span></span></span><br><span class="line"><span class="function"><span class="comment">// 所以对引用的修改等价于对原变量的修改。而如果不带&amp;，则传递的是一个值的副本，也就是</span></span></span><br><span class="line"><span class="function"><span class="comment">// 说，它会把变量复制一份，给一个新创建的变量，然后在这个函数里用的就是新的副本，对</span></span></span><br><span class="line"><span class="function"><span class="comment">// 副本的修改不会影响对原变量的修改</span></span></span><br><span class="line"><span class="function"><span class="comment">// 显然，传副本的话会占用更多空间，尤其是当变量很大的时候，就表现的很明显</span></span></span><br><span class="line"><span class="function"><span class="comment">// 所以传入引用是一种比较高效节约的方法。但需要注意是否修改了变量</span></span></span><br><span class="line"><span class="function"><span class="comment">// 不过因为这里确实没有修改变量，所以没问题</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 这个函数的目的是判断vector A里存储的数是否大于等于vector B里存储的数</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (A.<span class="built_in">size</span>() != B.<span class="built_in">size</span>()) <span class="keyword">return</span> A.<span class="built_in">size</span>() &gt; B.<span class="built_in">size</span>();   <span class="comment">// 如果二者位数不同，则可以直接return</span></span><br><span class="line">    <span class="comment">// 下面是二者位数相同的情况。则要比较大小，就是从高位到低位，逐位比较，一旦出现不同，就可以</span></span><br><span class="line">    <span class="comment">// 直接返回结果</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = A.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (A[i] != B[i]) <span class="keyword">return</span> A[i] &gt; B[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果到了这里，说明二者其实是相等的，也是返回true</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sub</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, vector&lt;<span class="type">int</span>&gt; &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 这个函数默认A是大于等于B的，这样下面写代码的时候逻辑会简单一点，不需要考虑如果负数的最高位</span></span><br><span class="line">    <span class="comment">// 上的借位之类的</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;  <span class="comment">// t是用于表示低位是否向当前位进行了借位</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        t = A[i] - t;   <span class="comment">// 这里，如果t是1，即前一位向当前位进行借位，则需要减掉1；如果t是0，</span></span><br><span class="line">        <span class="comment">// 即前一位没有向当前位进行借位，则减掉0，不影响</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.<span class="built_in">size</span>()) t = t - B[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>((t + <span class="number">10</span>) % <span class="number">10</span>);     <span class="comment">// 这里的push_back的结果是把正负两种情况统一了</span></span><br><span class="line">        <span class="keyword">if</span> (t &lt; <span class="number">0</span>) t = <span class="number">1</span>;   <span class="comment">// 统计判断一下是否发生了借位</span></span><br><span class="line">        <span class="keyword">else</span> t = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (C[C.<span class="built_in">size</span>() - <span class="number">1</span>] == <span class="number">0</span> &amp;&amp; C.<span class="built_in">size</span>() &gt; <span class="number">1</span>) C.<span class="built_in">pop_back</span>();      <span class="comment">// 这一步是用来删去前导零的</span></span><br><span class="line">    <span class="comment">// 最高位如果是0，且不是只有一位的情况（这种是，结果就是0，这个0还是要保留的）</span></span><br><span class="line">    <span class="comment">// 则去掉</span></span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string a, b;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; A, B;</span><br><span class="line">    </span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = a.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) A.<span class="built_in">push_back</span>(a[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = b.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) B.<span class="built_in">push_back</span>(b[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">cmp</span>(A, B))</span><br><span class="line">    &#123;</span><br><span class="line">        C = <span class="built_in">sub</span>(A, B);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">        C = <span class="built_in">sub</span>(B, A);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = C.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, C[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-3-高精度和低精度乘法（也就是一个大数和一个小数相乘）"><a href="#1-3-高精度和低精度乘法（也就是一个大数和一个小数相乘）" class="headerlink" title="1.3.高精度和低精度乘法（也就是一个大数和一个小数相乘）"></a>1.3.高精度和低精度乘法（也就是一个大数和一个小数相乘）</h2><h3 id="1-3-0-简介：换一种方法看待竖式乘法就好。列竖式的时候，是下面那个数的每一位与上面的那个数的每一位相乘。我们这里换一个方式来看。竖式的时候，我们把大数放到上面，小数放到下面，并且把小数视为一个整体x。乘积结果假设有k位数，从低到高是-c-0-dots-c-k-1-，这个结果可以看成是-c-0-10-0-c-1-10-1-dots-c-k-1-10-k-1-。小数x和第一位数字-a-1-相乘的时候，其实就是-a-1-x-10-0-；乘积结果的个位，也就是-c-0-，只可能由这个部分得到，并且-c-0-应该就是-a-1-x-对10取模。如果-a-1-x-大于等于10，那么它就应该拆解为-xxx-10-0-yyy-10-1-，其中-xxx-就应该是-a-1-x-对10取模，-yyy-就是剩下的部分，即-a-1-x-除10再向下取整。剩下的部分用于求-c-1-，因为-c-1-对应的是-10-1-。其余位也以此类推即可。所以看代码就行"><a href="#1-3-0-简介：换一种方法看待竖式乘法就好。列竖式的时候，是下面那个数的每一位与上面的那个数的每一位相乘。我们这里换一个方式来看。竖式的时候，我们把大数放到上面，小数放到下面，并且把小数视为一个整体x。乘积结果假设有k位数，从低到高是-c-0-dots-c-k-1-，这个结果可以看成是-c-0-10-0-c-1-10-1-dots-c-k-1-10-k-1-。小数x和第一位数字-a-1-相乘的时候，其实就是-a-1-x-10-0-；乘积结果的个位，也就是-c-0-，只可能由这个部分得到，并且-c-0-应该就是-a-1-x-对10取模。如果-a-1-x-大于等于10，那么它就应该拆解为-xxx-10-0-yyy-10-1-，其中-xxx-就应该是-a-1-x-对10取模，-yyy-就是剩下的部分，即-a-1-x-除10再向下取整。剩下的部分用于求-c-1-，因为-c-1-对应的是-10-1-。其余位也以此类推即可。所以看代码就行" class="headerlink" title="1.3.0.简介：换一种方法看待竖式乘法就好。列竖式的时候，是下面那个数的每一位与上面的那个数的每一位相乘。我们这里换一个方式来看。竖式的时候，我们把大数放到上面，小数放到下面，并且把小数视为一个整体x。乘积结果假设有k位数，从低到高是$c_{0}\dots c_{k-1}$，这个结果可以看成是$c_{0}*10^{0}+c_{1}*10^{1}+\dots+c_{k-1}*10^{k-1}$。小数x和第一位数字$a_{1}$相乘的时候，其实就是$a_{1} * x * 10^{0}$；乘积结果的个位，也就是$c_{0}$，只可能由这个部分得到，并且$c_{0}$应该就是$a_{1}*x$对10取模。如果$a_{1}*x$大于等于10，那么它就应该拆解为$xxx * 10^{0}+yyy * 10^{1}$，其中$xxx$就应该是$a_{1}*x$对10取模，$yyy$就是剩下的部分，即$a_{1}*x$除10再向下取整。剩下的部分用于求$c_{1}$，因为$c_{1}$对应的是$10^{1}$。其余位也以此类推即可。所以看代码就行"></a>1.3.0.简介：换一种方法看待竖式乘法就好。列竖式的时候，是下面那个数的每一位与上面的那个数的每一位相乘。我们这里换一个方式来看。竖式的时候，我们把大数放到上面，小数放到下面，并且把小数视为一个整体x。乘积结果假设有k位数，从低到高是$c_{0}\dots c_{k-1}$，这个结果可以看成是$c_{0}*10^{0}+c_{1}*10^{1}+\dots+c_{k-1}*10^{k-1}$。小数x和第一位数字$a_{1}$相乘的时候，其实就是$a_{1} * x * 10^{0}$；乘积结果的个位，也就是$c_{0}$，只可能由这个部分得到，并且$c_{0}$应该就是$a_{1}*x$对10取模。如果$a_{1}*x$大于等于10，那么它就应该拆解为$xxx * 10^{0}+yyy * 10^{1}$，其中$xxx$就应该是$a_{1}*x$对10取模，$yyy$就是剩下的部分，即$a_{1}*x$除10再向下取整。剩下的部分用于求$c_{1}$，因为$c_{1}$对应的是$10^{1}$。其余位也以此类推即可。所以看代码就行</h3><h3 id="1-3-1-代码模板"><a href="#1-3-1-代码模板" class="headerlink" title="1.3.1.代码模板"></a>1.3.1.代码模板</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C = A * b, A &gt;= 0, b &gt;= 0</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">mul</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>() || t; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; A.<span class="built_in">size</span>()) t += A[i] * b;</span><br><span class="line">        C.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>) C.<span class="built_in">pop_back</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：yxc</span><br><span class="line">链接：https:<span class="comment">//www.acwing.com/blog/content/277/</span></span><br><span class="line">来源：AcWing</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 带注释版本</span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">mul</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, <span class="type">int</span> &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>, i = <span class="number">0</span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">while</span> (t || i &lt; A.<span class="built_in">size</span>())   <span class="comment">// 判断条件中加上t，是因为需要把所有的进位都转化到结果上</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; A.<span class="built_in">size</span>()) </span><br><span class="line">        &#123;</span><br><span class="line">            t += A[i] * b;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        res.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (res.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; res.<span class="built_in">back</span>() == <span class="number">0</span>) res.<span class="built_in">pop_back</span>(); <span class="comment">// 去除前导0</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; A;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = a.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) A.<span class="built_in">push_back</span>(a[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res = <span class="built_in">mul</span>(A, b);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = res.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) cout &lt;&lt; res[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-4-高精度和低精度除法（也就是一个大数除以一个小数）"><a href="#1-4-高精度和低精度除法（也就是一个大数除以一个小数）" class="headerlink" title="1.4.高精度和低精度除法（也就是一个大数除以一个小数）"></a>1.4.高精度和低精度除法（也就是一个大数除以一个小数）</h2><h3 id="1-4-0-简介"><a href="#1-4-0-简介" class="headerlink" title="1.4.0.简介"></a>1.4.0.简介</h3><h3 id="1-4-1-代码模板"><a href="#1-4-1-代码模板" class="headerlink" title="1.4.1.代码模板"></a>1.4.1.代码模板</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A / b = C ... r, A &gt;= 0, b &gt; 0</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">div</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, <span class="type">int</span> b, <span class="type">int</span> &amp;r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = A.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- )</span><br><span class="line">    &#123;</span><br><span class="line">        r = r * <span class="number">10</span> + A[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>(r / b);</span><br><span class="line">        r %= b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(C.<span class="built_in">begin</span>(), C.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>) C.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：yxc</span><br><span class="line">链接：https:<span class="comment">//www.acwing.com/blog/content/277/</span></span><br><span class="line">来源：AcWing</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注释版本</span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">div</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, <span class="type">int</span> &amp;b, <span class="type">int</span> &amp;r)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 这个用一个专门的变量来存放余数的方法还是比较好的</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    r = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> i = A.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = A.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// t和r的计算方法其实是根据竖式除法的规则来的。或者也可以从权重的角度上理解</span></span><br><span class="line">        t = (r * <span class="number">10</span> + A[i]) / b;</span><br><span class="line">        res.<span class="built_in">push_back</span>(t);</span><br><span class="line">        r = (r * <span class="number">10</span> + A[i]) % b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">while</span> (res.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; res.<span class="built_in">back</span>() == <span class="number">0</span>) res.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; A;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = a.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) A.<span class="built_in">push_back</span>(a[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res = <span class="built_in">div</span>(A, b, r);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = res.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) cout &lt;&lt; res[i];</span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; r;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://gitookie.github.io/gitookie/2025/02/03/chap1.%E7%AC%AC%E4%B8%80%E8%AE%B2%20%20%E5%BF%AB%E6%8E%92%E5%92%8C%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E5%92%8C%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/gitookie/images/avatar.gif">
      <meta itemprop="name" content="bluemouse">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bluemouse's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/gitookie/2025/02/03/chap1.%E7%AC%AC%E4%B8%80%E8%AE%B2%20%20%E5%BF%AB%E6%8E%92%E5%92%8C%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E5%92%8C%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/" class="post-title-link" itemprop="url">Sans titre</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posté le</span>

              <time title="Article créé le: 2025-02-03 17:36:57" itemprop="dateCreated datePublished" datetime="2025-02-03T17:36:57+08:00">2025-02-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Édité le</span>
                <time title="Mis à jour le: 2025-02-01 11:33:14" itemprop="dateModified" datetime="2025-02-01T11:33:14+08:00">2025-02-01</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1-快速排序"><a href="#1-快速排序" class="headerlink" title="1.快速排序"></a>1.快速排序</h1><h2 id="1-1-核心思想：分治思想"><a href="#1-1-核心思想：分治思想" class="headerlink" title="1.1.核心思想：分治思想"></a>1.1.核心思想：分治思想</h2><h2 id="1-2-步骤："><a href="#1-2-步骤：" class="headerlink" title="1.2.步骤："></a>1.2.步骤：</h2><h3 id="1-2-1-对于一个给定的数组，选定一个中间值x（理论上来说，选哪个都行，但后面的代码需要注意相应的搭配，否则会陷入死循环。后面具体讲），常见的就是选数组的左边-右边-中间值-随机选"><a href="#1-2-1-对于一个给定的数组，选定一个中间值x（理论上来说，选哪个都行，但后面的代码需要注意相应的搭配，否则会陷入死循环。后面具体讲），常见的就是选数组的左边-右边-中间值-随机选" class="headerlink" title="1.2.1.对于一个给定的数组，选定一个中间值x（理论上来说，选哪个都行，但后面的代码需要注意相应的搭配，否则会陷入死循环。后面具体讲），常见的就是选数组的左边&#x2F;右边&#x2F;中间值&#x2F;随机选"></a>1.2.1.对于一个给定的数组，选定一个中间值x（理论上来说，选哪个都行，但后面的代码需要注意相应的搭配，否则会陷入死循环。后面具体讲），常见的就是选数组的左边&#x2F;右边&#x2F;中间值&#x2F;随机选</h3><h3 id="1-2-2-调整区间：这一步的目的是，调整数组，使得数组的左边部分的元素全都小于等于中间值x，右边部分的元素全都大于等于x（此时，一定有右边的元素大于等于左边的元素。这是快排正确性的保证）"><a href="#1-2-2-调整区间：这一步的目的是，调整数组，使得数组的左边部分的元素全都小于等于中间值x，右边部分的元素全都大于等于x（此时，一定有右边的元素大于等于左边的元素。这是快排正确性的保证）" class="headerlink" title="1.2.2.调整区间：这一步的目的是，调整数组，使得数组的左边部分的元素全都小于等于中间值x，右边部分的元素全都大于等于x（此时，一定有右边的元素大于等于左边的元素。这是快排正确性的保证）"></a>1.2.2.调整区间：这一步的目的是，调整数组，使得数组的左边部分的元素全都小于等于中间值x，右边部分的元素全都大于等于x（此时，一定有右边的元素大于等于左边的元素。这是快排正确性的保证）</h3><h3 id="1-2-3-递归：对上面的左边和右边部分的子数组也进行1-2-1-1-2-2的操作"><a href="#1-2-3-递归：对上面的左边和右边部分的子数组也进行1-2-1-1-2-2的操作" class="headerlink" title="1.2.3.递归：对上面的左边和右边部分的子数组也进行1.2.1-1.2.2的操作"></a>1.2.3.递归：对上面的左边和右边部分的子数组也进行1.2.1-1.2.2的操作</h3><h3 id="可以看到，核心步骤应该是1-2-2。而关于1-2-2的实现，一个比较简单粗暴的方法是，再开两个数组a，b，然后，从左到右扫描一遍待排序的数组s，如果一个元素小于等于中间值，则放到数组a里，大于中间值，则放到b里。扫描完之后，先把a的元素放回s里，再把b的元素放回s里（放回去的顺序也从左往右即可），就完成了。时间复杂度上，因为要扫描一遍，放回一遍，应该是2N，也就是-O-N-；主要的问题在空间复杂度上，需要再开两个数组，不太好"><a href="#可以看到，核心步骤应该是1-2-2。而关于1-2-2的实现，一个比较简单粗暴的方法是，再开两个数组a，b，然后，从左到右扫描一遍待排序的数组s，如果一个元素小于等于中间值，则放到数组a里，大于中间值，则放到b里。扫描完之后，先把a的元素放回s里，再把b的元素放回s里（放回去的顺序也从左往右即可），就完成了。时间复杂度上，因为要扫描一遍，放回一遍，应该是2N，也就是-O-N-；主要的问题在空间复杂度上，需要再开两个数组，不太好" class="headerlink" title="可以看到，核心步骤应该是1.2.2。而关于1.2.2的实现，一个比较简单粗暴的方法是，再开两个数组a，b，然后，从左到右扫描一遍待排序的数组s，如果一个元素小于等于中间值，则放到数组a里，大于中间值，则放到b里。扫描完之后，先把a的元素放回s里，再把b的元素放回s里（放回去的顺序也从左往右即可），就完成了。时间复杂度上，因为要扫描一遍，放回一遍，应该是2N，也就是$O(N)$；主要的问题在空间复杂度上，需要再开两个数组，不太好"></a>可以看到，核心步骤应该是1.2.2。而关于1.2.2的实现，一个比较简单粗暴的方法是，再开两个数组a，b，然后，从左到右扫描一遍待排序的数组s，如果一个元素小于等于中间值，则放到数组a里，大于中间值，则放到b里。扫描完之后，先把a的元素放回s里，再把b的元素放回s里（放回去的顺序也从左往右即可），就完成了。时间复杂度上，因为要扫描一遍，放回一遍，应该是2N，也就是$O(N)$；主要的问题在空间复杂度上，需要再开两个数组，不太好</h3><h3 id="而我个人的第一想法是，（本质也是一个双指针法）"><a href="#而我个人的第一想法是，（本质也是一个双指针法）" class="headerlink" title="而我个人的第一想法是，（本质也是一个双指针法）"></a>而我个人的第一想法是，（本质也是一个双指针法）</h3><h4 id="给一组双指针，起始分别在s的最左边和最右边。"><a href="#给一组双指针，起始分别在s的最左边和最右边。" class="headerlink" title="给一组双指针，起始分别在s的最左边和最右边。"></a>给一组双指针，起始分别在s的最左边和最右边。</h4><h4 id="左指针从左往右移动，如果当前左指针指向的元素小于等于中间值x，则不动它，继续往右走一格；如果当前左指针指向的元素大于中间值x，则把它和s的右指针指向的元素替换，同时右指针往左走一格，左指针先不动：换过来的新元素如果小于等于x，则左指针往右走一格；如果缓过来的新元素还是大于x，则再让它和右指针指向的元素交换一下（注意，上面已经让右指针往左走一格了），"><a href="#左指针从左往右移动，如果当前左指针指向的元素小于等于中间值x，则不动它，继续往右走一格；如果当前左指针指向的元素大于中间值x，则把它和s的右指针指向的元素替换，同时右指针往左走一格，左指针先不动：换过来的新元素如果小于等于x，则左指针往右走一格；如果缓过来的新元素还是大于x，则再让它和右指针指向的元素交换一下（注意，上面已经让右指针往左走一格了），" class="headerlink" title="左指针从左往右移动，如果当前左指针指向的元素小于等于中间值x，则不动它，继续往右走一格；如果当前左指针指向的元素大于中间值x，则把它和s的右指针指向的元素替换，同时右指针往左走一格，左指针先不动：换过来的新元素如果小于等于x，则左指针往右走一格；如果缓过来的新元素还是大于x，则再让它和右指针指向的元素交换一下（注意，上面已经让右指针往左走一格了），"></a>左指针从左往右移动，如果当前左指针指向的元素小于等于中间值x，则不动它，继续往右走一格；如果当前左指针指向的元素大于中间值x，则把它和s的右指针指向的元素替换，同时右指针往左走一格，左指针先不动：换过来的新元素如果小于等于x，则左指针往右走一格；如果缓过来的新元素还是大于x，则再让它和右指针指向的元素交换一下（注意，上面已经让右指针往左走一格了），</h4><h4 id="然后一直重复上面的判断，直到左指针继续往右走了，或者是右指针一直往左走，走到了与左指针相遇的位置（感觉其实已经很接近给的模板了）"><a href="#然后一直重复上面的判断，直到左指针继续往右走了，或者是右指针一直往左走，走到了与左指针相遇的位置（感觉其实已经很接近给的模板了）" class="headerlink" title="然后一直重复上面的判断，直到左指针继续往右走了，或者是右指针一直往左走，走到了与左指针相遇的位置（感觉其实已经很接近给的模板了）"></a>然后一直重复上面的判断，直到左指针继续往右走了，或者是右指针一直往左走，走到了与左指针相遇的位置（感觉其实已经很接近给的模板了）</h4><h3 id="模板的话，是一个双指针，比我的稍微简洁一点。主要的改进在于，我的方法在遇到左指针元素大于x的时候，一定会和右指针元素交换，且右指针一定往走一格；而模板的方法是，"><a href="#模板的话，是一个双指针，比我的稍微简洁一点。主要的改进在于，我的方法在遇到左指针元素大于x的时候，一定会和右指针元素交换，且右指针一定往走一格；而模板的方法是，" class="headerlink" title="模板的话，是一个双指针，比我的稍微简洁一点。主要的改进在于，我的方法在遇到左指针元素大于x的时候，一定会和右指针元素交换，且右指针一定往走一格；而模板的方法是，"></a>模板的话，是一个双指针，比我的稍微简洁一点。主要的改进在于，我的方法在遇到左指针元素大于x的时候，一定会和右指针元素交换，且右指针一定往走一格；而模板的方法是，</h3><h4 id="如果左指针元素小于x，则符合要求，左指针往右走一格；如果左指针元素大于等于x，则我不动左指针了，去移动右指针：如果右指针元素大于x，也符合要求，则右指针往左走一格；如果右指针元素小于等于x，则现在的情况是：左指针元素大于等于x，右指针元素小于等于x，它们交换一下就刚好符合要求了，故交换左右指针指向的元素。之后继续移动左指针，重复上面的步骤，直至左右指针相遇（或者右指针第一次走到左指针左边-左指针第一次走到右指针右边）。代码模板如下："><a href="#如果左指针元素小于x，则符合要求，左指针往右走一格；如果左指针元素大于等于x，则我不动左指针了，去移动右指针：如果右指针元素大于x，也符合要求，则右指针往左走一格；如果右指针元素小于等于x，则现在的情况是：左指针元素大于等于x，右指针元素小于等于x，它们交换一下就刚好符合要求了，故交换左右指针指向的元素。之后继续移动左指针，重复上面的步骤，直至左右指针相遇（或者右指针第一次走到左指针左边-左指针第一次走到右指针右边）。代码模板如下：" class="headerlink" title="如果左指针元素小于x，则符合要求，左指针往右走一格；如果左指针元素大于等于x，则我不动左指针了，去移动右指针：如果右指针元素大于x，也符合要求，则右指针往左走一格；如果右指针元素小于等于x，则现在的情况是：左指针元素大于等于x，右指针元素小于等于x，它们交换一下就刚好符合要求了，故交换左右指针指向的元素。之后继续移动左指针，重复上面的步骤，直至左右指针相遇（或者右指针第一次走到左指针左边&#x2F;左指针第一次走到右指针右边）。代码模板如下："></a>如果左指针元素小于x，则符合要求，左指针往右走一格；如果左指针元素大于等于x，则我不动左指针了，去移动右指针：如果右指针元素大于x，也符合要求，则右指针往左走一格；如果右指针元素小于等于x，则现在的情况是：左指针元素大于等于x，右指针元素小于等于x，它们交换一下就刚好符合要求了，故交换左右指针指向的元素。之后继续移动左指针，重复上面的步骤，直至左右指针相遇（或者右指针第一次走到左指针左边&#x2F;左指针第一次走到右指针右边）。代码模板如下：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = l - <span class="number">1</span>, j = r + <span class="number">1</span>, x = q[l + r &gt;&gt; <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span> i ++ ; <span class="keyword">while</span> (q[i] &lt; x);</span><br><span class="line">        <span class="keyword">do</span> j -- ; <span class="keyword">while</span> (q[j] &gt; x);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) <span class="built_in">swap</span>(q[i], q[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">quick_sort</span>(q, l, j), <span class="built_in">quick_sort</span>(q, j + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：yxc</span><br><span class="line">链接：https:<span class="comment">//www.acwing.com/blog/content/277/</span></span><br><span class="line">来源：AcWing</span><br></pre></td></tr></table></figure>
<h2 id="问题：模板变化的原理是？就是说，如果后面递归的时候，用i来划分边界，quick-sort-q-l-i-1-quick-sort-q-i-r-，则上面选枢纽元的时候不能选q-l-？类似的，用j来划分边界的时候，枢纽元就不能取q-r-？为什么？"><a href="#问题：模板变化的原理是？就是说，如果后面递归的时候，用i来划分边界，quick-sort-q-l-i-1-quick-sort-q-i-r-，则上面选枢纽元的时候不能选q-l-？类似的，用j来划分边界的时候，枢纽元就不能取q-r-？为什么？" class="headerlink" title="问题：模板变化的原理是？就是说，如果后面递归的时候，用i来划分边界，quick_sort(q, l, i - 1), quick_sort(q, i, r)，则上面选枢纽元的时候不能选q[l]？类似的，用j来划分边界的时候，枢纽元就不能取q[r]？为什么？"></a>问题：模板变化的原理是？就是说，如果后面递归的时候，用i来划分边界，quick_sort(q, l, i - 1), quick_sort(q, i, r)，则上面选枢纽元的时候不能选q[l]？类似的，用j来划分边界的时候，枢纽元就不能取q[r]？为什么？</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误典范一：两个子while循环的判断条件中，带上了“等于”</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> pivot = arr[mid];</span><br><span class="line">    <span class="comment">// int i = l - 1, j = r + 1;</span></span><br><span class="line">    <span class="type">int</span> i = l, j = r;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; i &lt;&lt; j;</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; i &lt;&lt; j;</span></span><br><span class="line">        <span class="comment">// i++;        // 看起来，似乎不在里面的两个while循环前移动指针，也不会有什么问题，因为：</span></span><br><span class="line">        <span class="comment">// 一个大的while循环结束之后，左右指针指向的元素应该都是符合要求的（左指针元素大于等于</span></span><br><span class="line">        <span class="comment">// pivot，右指针元素小于等于pivot）。此时开始一个新的while大循环，并不会有什么问题，在</span></span><br><span class="line">        <span class="comment">// 两个小的while循环中，应该会正常的通过，然后相应移动指针。。。</span></span><br><span class="line">        <span class="comment">// 但问题就是出在我们认为的“应该会正常通过”。事实上，一个大循环完了，确实左右指针的元素</span></span><br><span class="line">        <span class="comment">// 符合要求，但未必就能进到两个小的while循环里。</span></span><br><span class="line">        <span class="comment">// 这是因为，如果某个时刻出现：左右指针指向</span></span><br><span class="line">        <span class="comment">// 的元素都是pivot，则两个while都不会执行，swap也不会产生什么效果，然后再进到新的</span></span><br><span class="line">        <span class="comment">// while(i &lt; j)的循环中时，也是如此。就一直卡这里了，所以会超时</span></span><br><span class="line">        <span class="comment">// 说到底，其实是因为我们的两个子循环的判断条件导致的：都是严格的小于/大于，而不是</span></span><br><span class="line">        <span class="comment">// 小于等于/大于等于</span></span><br><span class="line">        <span class="keyword">while</span> (arr[i] &lt;= pivot &amp;&amp; i &lt; j) i++;       <span class="comment">// 像现在这样，判断条件中加上等于的话，</span></span><br><span class="line">        <span class="comment">// 看起来没什么问题，可如果出现一个数组里所有元素相等的极端情况的话，最终i就会变成r，</span></span><br><span class="line">        <span class="comment">// j也还是r不变，则下面的两个递归调用中，第一个就和现在的是一样的了，所以会一直递归调用</span></span><br><span class="line">        <span class="comment">// 陷入死循环</span></span><br><span class="line">        <span class="comment">// cout &lt;&lt; i;</span></span><br><span class="line">        <span class="comment">// j--;</span></span><br><span class="line">        <span class="keyword">while</span> (arr[j] &gt;= pivot &amp;&amp; j &gt; i) j--;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; j;</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) <span class="built_in">swap</span>(arr[i], arr[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">quick_sort</span>(arr, l, j);</span><br><span class="line">    <span class="built_in">quick_sort</span>(arr, j + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误典范二：在两个子while循环中不先移动一下指针</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> pivot = arr[mid];</span><br><span class="line">    <span class="comment">// int i = l - 1, j = r + 1;</span></span><br><span class="line">    <span class="type">int</span> i = l, j = r;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; i &lt;&lt; j;</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; i &lt;&lt; j;</span></span><br><span class="line">        <span class="comment">// i++;        // 看起来，似乎不在里面的两个while循环前移动指针，也不会有什么问题，因为：</span></span><br><span class="line">        <span class="comment">// 一个大的while循环结束之后，左右指针指向的元素应该都是符合要求的（左指针元素大于等于</span></span><br><span class="line">        <span class="comment">// pivot，右指针元素小于等于pivot）。此时开始一个新的while大循环，并不会有什么问题，在</span></span><br><span class="line">        <span class="comment">// 两个小的while循环中，应该会正常的通过，然后相应移动指针。。。</span></span><br><span class="line">        <span class="comment">// 但问题就是出在我们认为的“应该会正常通过”。事实上，一个大循环完了，确实左右指针的元素</span></span><br><span class="line">        <span class="comment">// 符合要求，但未必就能进到两个小的while循环里。</span></span><br><span class="line">        <span class="comment">// 这是因为，如果某个时刻出现：左右指针指向</span></span><br><span class="line">        <span class="comment">// 的元素都是pivot，则两个while都不会执行，swap也不会产生什么效果，然后再进到新的</span></span><br><span class="line">        <span class="comment">// while(i &lt; j)的循环中时，也是如此。就一直卡这里了，所以会超时</span></span><br><span class="line">        <span class="comment">// 说到底，其实是因为我们的两个子循环的判断条件导致的：都是严格的小于/大于，而不是</span></span><br><span class="line">        <span class="comment">// 小于等于/大于等于</span></span><br><span class="line">        <span class="keyword">while</span> (arr[i] &lt; pivot) i++;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; i;</span></span><br><span class="line">        <span class="comment">// j--;</span></span><br><span class="line">        <span class="keyword">while</span> (arr[j] &gt; pivot) j--;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; j;</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) <span class="built_in">swap</span>(arr[i], arr[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">quick_sort</span>(arr, l, j);</span><br><span class="line">    <span class="built_in">quick_sort</span>(arr, j + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="2-归并排序"><a href="#2-归并排序" class="headerlink" title="2.归并排序"></a>2.归并排序</h1><h2 id="1-1-核心思想：分治思想-1"><a href="#1-1-核心思想：分治思想-1" class="headerlink" title="1.1.核心思想：分治思想"></a>1.1.核心思想：分治思想</h2><h2 id="1-2-大致流程："><a href="#1-2-大致流程：" class="headerlink" title="1.2.大致流程："></a>1.2.大致流程：</h2><h3 id="这里也会选一个类似枢纽元的元素，但是是固定选取为中间的那个元素。我们的目标是把左半边和右半边的部分元素都排好序，这样左右半边都是一个有序数组，最后就可以用一个双指针法进行合并，从而得到最终结果。显然，这里的关键在于如何快速高效地把左半边和右半边排好序，以及如何合并结果。下面是详细步骤"><a href="#这里也会选一个类似枢纽元的元素，但是是固定选取为中间的那个元素。我们的目标是把左半边和右半边的部分元素都排好序，这样左右半边都是一个有序数组，最后就可以用一个双指针法进行合并，从而得到最终结果。显然，这里的关键在于如何快速高效地把左半边和右半边排好序，以及如何合并结果。下面是详细步骤" class="headerlink" title="这里也会选一个类似枢纽元的元素，但是是固定选取为中间的那个元素。我们的目标是把左半边和右半边的部分元素都排好序，这样左右半边都是一个有序数组，最后就可以用一个双指针法进行合并，从而得到最终结果。显然，这里的关键在于如何快速高效地把左半边和右半边排好序，以及如何合并结果。下面是详细步骤"></a>这里也会选一个类似枢纽元的元素，但是是固定选取为中间的那个元素。我们的目标是把左半边和右半边的部分元素都排好序，这样左右半边都是一个有序数组，最后就可以用一个双指针法进行合并，从而得到最终结果。显然，这里的关键在于如何快速高效地把左半边和右半边排好序，以及如何合并结果。下面是详细步骤</h3><h2 id="1-3-步骤："><a href="#1-3-步骤：" class="headerlink" title="1.3.步骤："></a>1.3.步骤：</h2><h3 id="1-3-1-先明确一下递归结束的条件：若当前数组只有一个元素，或没有元素，则递归结束，return；否则还需继续进行递归，那么就选择中间元素，就是字面意思地进行选择"><a href="#1-3-1-先明确一下递归结束的条件：若当前数组只有一个元素，或没有元素，则递归结束，return；否则还需继续进行递归，那么就选择中间元素，就是字面意思地进行选择" class="headerlink" title="1.3.1.先明确一下递归结束的条件：若当前数组只有一个元素，或没有元素，则递归结束，return；否则还需继续进行递归，那么就选择中间元素，就是字面意思地进行选择"></a>1.3.1.先明确一下递归结束的条件：若当前数组只有一个元素，或没有元素，则递归结束，return；否则还需继续进行递归，那么就选择中间元素，就是字面意思地进行选择</h3><h3 id="1-3-2-递归地对左右半边调用归并排序算法的函数（这里回答了上面提到的，如何快速高效地把左半边和右半边排好序）（理解上，我们可以认为，递归排序算法已经写好，对左半边和右半边调用这个函数就可以实现排序）"><a href="#1-3-2-递归地对左右半边调用归并排序算法的函数（这里回答了上面提到的，如何快速高效地把左半边和右半边排好序）（理解上，我们可以认为，递归排序算法已经写好，对左半边和右半边调用这个函数就可以实现排序）" class="headerlink" title="1.3.2.递归地对左右半边调用归并排序算法的函数（这里回答了上面提到的，如何快速高效地把左半边和右半边排好序）（理解上，我们可以认为，递归排序算法已经写好，对左半边和右半边调用这个函数就可以实现排序）"></a>1.3.2.递归地对左右半边调用归并排序算法的函数（这里回答了上面提到的，如何快速高效地把左半边和右半边排好序）（理解上，我们可以认为，递归排序算法已经写好，对左半边和右半边调用这个函数就可以实现排序）</h3><h3 id="1-3-3-合并。现在已经得到了左右半边两个有序的数组，就要进行合并了。原理上是很简单的。初始化两个指针，分别指向左半边的开始和右半边的开始，然后开始移动。比较当前两个指针的元素，指向元素较小的那个指针，把它指向的那个元素存到一个中间数组里（往中间数组里存储，也是从左往右的），并把指针往右移动一格；如果遇到当前双指针指向的元素相同的情况，那么我们一般是选择把左半边的那个指针的元素存到中间数组，并移动左半边的那个指针（因为这样可以保证归并排序是稳定的。下面会细讲。反正这个影响不大）。如此一直重复，直至有某个指针第一次到达了它的终点。此时若另一个指针还没到终点，则把它当前指向的元素及后面所有的元素都一并复制到中间数组里。至此，合并完成"><a href="#1-3-3-合并。现在已经得到了左右半边两个有序的数组，就要进行合并了。原理上是很简单的。初始化两个指针，分别指向左半边的开始和右半边的开始，然后开始移动。比较当前两个指针的元素，指向元素较小的那个指针，把它指向的那个元素存到一个中间数组里（往中间数组里存储，也是从左往右的），并把指针往右移动一格；如果遇到当前双指针指向的元素相同的情况，那么我们一般是选择把左半边的那个指针的元素存到中间数组，并移动左半边的那个指针（因为这样可以保证归并排序是稳定的。下面会细讲。反正这个影响不大）。如此一直重复，直至有某个指针第一次到达了它的终点。此时若另一个指针还没到终点，则把它当前指向的元素及后面所有的元素都一并复制到中间数组里。至此，合并完成" class="headerlink" title="1.3.3.合并。现在已经得到了左右半边两个有序的数组，就要进行合并了。原理上是很简单的。初始化两个指针，分别指向左半边的开始和右半边的开始，然后开始移动。比较当前两个指针的元素，指向元素较小的那个指针，把它指向的那个元素存到一个中间数组里（往中间数组里存储，也是从左往右的），并把指针往右移动一格；如果遇到当前双指针指向的元素相同的情况，那么我们一般是选择把左半边的那个指针的元素存到中间数组，并移动左半边的那个指针（因为这样可以保证归并排序是稳定的。下面会细讲。反正这个影响不大）。如此一直重复，直至有某个指针第一次到达了它的终点。此时若另一个指针还没到终点，则把它当前指向的元素及后面所有的元素都一并复制到中间数组里。至此，合并完成"></a>1.3.3.合并。现在已经得到了左右半边两个有序的数组，就要进行合并了。原理上是很简单的。<br>初始化两个指针，分别指向左半边的开始和右半边的开始，然后开始移动。比较当前两个指针的元素，指向元素较小的那个指针，把它指向的那个元素存到一个中间数组里（往中间数组里存储，也是从左往右的），并把指针往右移动一格；如果遇到当前双指针指向的元素相同的情况，那么我们一般是选择把左半边的那个指针的元素存到中间数组，并移动左半边的那个指针（因为这样可以保证归并排序是稳定的。下面会细讲。反正这个影响不大）。<br>如此一直重复，直至有某个指针第一次到达了它的终点。此时若另一个指针还没到终点，则把它当前指向的元素及后面所有的元素都一并复制到中间数组里。至此，合并完成</h3><h2 id="1-4-代码模板"><a href="#1-4-代码模板" class="headerlink" title="1.4.代码模板"></a>1.4.代码模板</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">merge_sort</span>(q, l, mid);</span><br><span class="line">    <span class="built_in">merge_sort</span>(q, mid + <span class="number">1</span>, r);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>, i = l, j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r)</span><br><span class="line">        <span class="keyword">if</span> (q[i] &lt;= q[j]) tmp[k ++ ] = q[i ++ ];</span><br><span class="line">        <span class="keyword">else</span> tmp[k ++ ] = q[j ++ ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) tmp[k ++ ] = q[i ++ ];</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= r) tmp[k ++ ] = q[j ++ ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = l, j = <span class="number">0</span>; i &lt;= r; i ++, j ++ ) q[i] = tmp[j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：yxc</span><br><span class="line">链接：https:<span class="comment">//www.acwing.com/blog/content/277/</span></span><br><span class="line">来源：AcWing</span><br></pre></td></tr></table></figure>
<h1 id="3-二分查找"><a href="#3-二分查找" class="headerlink" title="3.二分查找"></a>3.二分查找</h1><h2 id="3-0-概述：二分查找，顾名思义，是一种用来查找指定元素的算法。它大致有两种，一种是整数二分，即在一个有序的整数序列中查找指定元素；一种是浮点数二分，或者说实数二分，即在一个有序的实数区间里查找指定元素（当然一般找到的可能是一个近似值）。比较麻烦的是整数二分，因为它需要一些边界条件的判断。而实数二分就比较简单了，没有什么边界问题"><a href="#3-0-概述：二分查找，顾名思义，是一种用来查找指定元素的算法。它大致有两种，一种是整数二分，即在一个有序的整数序列中查找指定元素；一种是浮点数二分，或者说实数二分，即在一个有序的实数区间里查找指定元素（当然一般找到的可能是一个近似值）。比较麻烦的是整数二分，因为它需要一些边界条件的判断。而实数二分就比较简单了，没有什么边界问题" class="headerlink" title="3.0.概述：二分查找，顾名思义，是一种用来查找指定元素的算法。它大致有两种，一种是整数二分，即在一个有序的整数序列中查找指定元素；一种是浮点数二分，或者说实数二分，即在一个有序的实数区间里查找指定元素（当然一般找到的可能是一个近似值）。比较麻烦的是整数二分，因为它需要一些边界条件的判断。而实数二分就比较简单了，没有什么边界问题"></a>3.0.概述：二分查找，顾名思义，是一种用来查找指定元素的算法。它大致有两种，一种是整数二分，即在一个有序的整数序列中查找指定元素；一种是浮点数二分，或者说实数二分，即在一个有序的实数区间里查找指定元素（当然一般找到的可能是一个近似值）。比较麻烦的是整数二分，因为它需要一些边界条件的判断。而实数二分就比较简单了，没有什么边界问题</h2><h2 id="3-1-核心思想：需要澄清的一点是，单调性是有利于二分查找的，但并不意味着要用二分查找就一定要求输入满足单调性。更抽象地说，二分，它“分”的依据是，某个元素，如果它满足一定性质，则它的左边或它的右边，一定会全都满足某种性质。单调性是其中的一种特例。譬如，一个整数序列，它是单调递增的。我们想找元素x，如果当前元素a它小于x，根据单调性，a右边的所有元素应该都大于等于a（这就是我们说的，它的左边或它的右边，一定会全都满足某种性质），因此x也应该在a的右边。由此我们就缩小了查找x的范围了"><a href="#3-1-核心思想：需要澄清的一点是，单调性是有利于二分查找的，但并不意味着要用二分查找就一定要求输入满足单调性。更抽象地说，二分，它“分”的依据是，某个元素，如果它满足一定性质，则它的左边或它的右边，一定会全都满足某种性质。单调性是其中的一种特例。譬如，一个整数序列，它是单调递增的。我们想找元素x，如果当前元素a它小于x，根据单调性，a右边的所有元素应该都大于等于a（这就是我们说的，它的左边或它的右边，一定会全都满足某种性质），因此x也应该在a的右边。由此我们就缩小了查找x的范围了" class="headerlink" title="3.1.核心思想：需要澄清的一点是，单调性是有利于二分查找的，但并不意味着要用二分查找就一定要求输入满足单调性。更抽象地说，二分，它“分”的依据是，某个元素，如果它满足一定性质，则它的左边或它的右边，一定会全都满足某种性质。单调性是其中的一种特例。譬如，一个整数序列，它是单调递增的。我们想找元素x，如果当前元素a它小于x，根据单调性，a右边的所有元素应该都大于等于a（这就是我们说的，它的左边或它的右边，一定会全都满足某种性质），因此x也应该在a的右边。由此我们就缩小了查找x的范围了"></a>3.1.核心思想：需要澄清的一点是，单调性是有利于二分查找的，但并不意味着要用二分查找就一定要求输入满足单调性。更抽象地说，二分，它“分”的依据是，某个元素，如果它满足一定性质，则它的左边或它的右边，一定会全都满足某种性质。单调性是其中的一种特例。譬如，一个整数序列，它是单调递增的。我们想找元素x，如果当前元素a它小于x，根据单调性，a右边的所有元素应该都大于等于a（这就是我们说的，它的左边或它的右边，一定会全都满足某种性质），因此x也应该在a的右边。由此我们就缩小了查找x的范围了</h2><h2 id="3-2-具体步骤："><a href="#3-2-具体步骤：" class="headerlink" title="3.2.具体步骤："></a>3.2.具体步骤：</h2><h3 id="3-2-1-整数二分"><a href="#3-2-1-整数二分" class="headerlink" title="3.2.1.整数二分"></a>3.2.1.整数二分</h3><h4 id="比方说，我们要在一个升序排列的数组里找到一个指定元素x，通常的思路是先找到中间那个元素mid，看看它是比x大还是小：如果它比x大，则x一定在左半边；反之，x在右半边。在缩小的那半边里继续这一套流程，直至区间里只有一个元素，这就是我们查找的结果上面的内容里有两点需要注意，一个是中间元素mid怎么找。看起来无关紧要，但代码实现上的时候，这里会影响到后面的代码实现，且很容易出错；第二点是“查找结果”，我们的整数二分是一定会有一个结果的，但本身这个待查找元素x未必就在数组里。也就是说，即使数组里没有这个元素，我们用朴素的整数二分，不做其它的处理，还是会得到一个“伪答案”。所以实际看题目，如果题目说查找元素未必存在，就需要多一些处理逻辑"><a href="#比方说，我们要在一个升序排列的数组里找到一个指定元素x，通常的思路是先找到中间那个元素mid，看看它是比x大还是小：如果它比x大，则x一定在左半边；反之，x在右半边。在缩小的那半边里继续这一套流程，直至区间里只有一个元素，这就是我们查找的结果上面的内容里有两点需要注意，一个是中间元素mid怎么找。看起来无关紧要，但代码实现上的时候，这里会影响到后面的代码实现，且很容易出错；第二点是“查找结果”，我们的整数二分是一定会有一个结果的，但本身这个待查找元素x未必就在数组里。也就是说，即使数组里没有这个元素，我们用朴素的整数二分，不做其它的处理，还是会得到一个“伪答案”。所以实际看题目，如果题目说查找元素未必存在，就需要多一些处理逻辑" class="headerlink" title="比方说，我们要在一个升序排列的数组里找到一个指定元素x，通常的思路是先找到中间那个元素mid，看看它是比x大还是小：如果它比x大，则x一定在左半边；反之，x在右半边。在缩小的那半边里继续这一套流程，直至区间里只有一个元素，这就是我们查找的结果上面的内容里有两点需要注意，一个是中间元素mid怎么找。看起来无关紧要，但代码实现上的时候，这里会影响到后面的代码实现，且很容易出错；第二点是“查找结果”，我们的整数二分是一定会有一个结果的，但本身这个待查找元素x未必就在数组里。也就是说，即使数组里没有这个元素，我们用朴素的整数二分，不做其它的处理，还是会得到一个“伪答案”。所以实际看题目，如果题目说查找元素未必存在，就需要多一些处理逻辑"></a>比方说，我们要在一个升序排列的数组里找到一个指定元素x，通常的思路是先找到中间那个元素mid，看看它是比x大还是小：如果它比x大，则x一定在左半边；反之，x在右半边。在缩小的那半边里继续这一套流程，直至区间里只有一个元素，这就是我们查找的结果<br>上面的内容里有两点需要注意，一个是中间元素mid怎么找。看起来无关紧要，但代码实现上的时候，这里会影响到后面的代码实现，且很容易出错；第二点是“查找结果”，我们的整数二分是一定会有一个结果的，但本身这个待查找元素x未必就在数组里。也就是说，即使数组里没有这个元素，我们用朴素的整数二分，不做其它的处理，还是会得到一个“伪答案”。所以实际看题目，如果题目说查找元素未必存在，就需要多一些处理逻辑</h4><h4 id="代码模板"><a href="#代码模板" class="headerlink" title="代码模板"></a>代码模板</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="comment">/* ... */</span>&#125; <span class="comment">// 检查x是否满足某种性质</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bsearch_1</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) r = mid;    <span class="comment">// check()判断mid是否满足性质</span></span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bsearch_2</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) l = mid;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：yxc</span><br><span class="line">链接：https:<span class="comment">//www.acwing.com/blog/content/277/</span></span><br><span class="line">来源：AcWing</span><br></pre></td></tr></table></figure>
<h4 id="对上面的代码简单说明一下。check函数其实是一种广义的函数，它未必就是比大小，需要看题目要求然后上面是实现了两种二分查找。可以看到，两种方法的mid取法是不一样的，且影响到后面区间的缩减。实际我们应用的时候，不需要死记硬背套这两个模板。比较自然的思路是，我们会依据题目条件，先写好一个check，并把区间缩减的方式写好。之后，我们可以再去更改mid的取法。而之所以会有两种不同的取法，主要是因为，在第二种方法中，有if-check-mid-l-mid-这一行。如果mid还是取为l-r-1，则当l仅比r小1的时候，如果check-mid-成立了，l-mid，而此时mid还是l，就陷入了死循环了。所以必须要加上一个1"><a href="#对上面的代码简单说明一下。check函数其实是一种广义的函数，它未必就是比大小，需要看题目要求然后上面是实现了两种二分查找。可以看到，两种方法的mid取法是不一样的，且影响到后面区间的缩减。实际我们应用的时候，不需要死记硬背套这两个模板。比较自然的思路是，我们会依据题目条件，先写好一个check，并把区间缩减的方式写好。之后，我们可以再去更改mid的取法。而之所以会有两种不同的取法，主要是因为，在第二种方法中，有if-check-mid-l-mid-这一行。如果mid还是取为l-r-1，则当l仅比r小1的时候，如果check-mid-成立了，l-mid，而此时mid还是l，就陷入了死循环了。所以必须要加上一个1" class="headerlink" title="对上面的代码简单说明一下。check函数其实是一种广义的函数，它未必就是比大小，需要看题目要求然后上面是实现了两种二分查找。可以看到，两种方法的mid取法是不一样的，且影响到后面区间的缩减。实际我们应用的时候，不需要死记硬背套这两个模板。比较自然的思路是，我们会依据题目条件，先写好一个check，并把区间缩减的方式写好。之后，我们可以再去更改mid的取法。而之所以会有两种不同的取法，主要是因为，在第二种方法中，有if (check(mid)) l = mid;这一行。如果mid还是取为l + r &gt;&gt; 1，则当l仅比r小1的时候，如果check(mid)成立了，l&#x3D;mid，而此时mid还是l，就陷入了死循环了。所以必须要加上一个1"></a>对上面的代码简单说明一下。check函数其实是一种广义的函数，它未必就是比大小，需要看题目要求<br>然后上面是实现了两种二分查找。可以看到，两种方法的mid取法是不一样的，且影响到后面区间的缩减。实际我们应用的时候，不需要死记硬背套这两个模板。比较自然的思路是，我们会依据题目条件，先写好一个check，并把区间缩减的方式写好。之后，我们可以再去更改mid的取法。而之所以会有两种不同的取法，主要是因为，在第二种方法中，有<code>if (check(mid)) l = mid;</code>这一行。如果mid还是取为l + r &gt;&gt; 1，则当l仅比r小1的时候，如果check(mid)成立了，l&#x3D;mid，而此时mid还是l，就陷入了死循环了。所以必须要加上一个1</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> n, q;</span><br><span class="line"><span class="type">int</span> arr[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;q);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;arr[i]);</span><br><span class="line">    <span class="keyword">while</span> (q--)     <span class="comment">//while(q--)的写法，刚好会循环q次</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> query;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;query);</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//下面这个for循环是用来找query出现的起始位置的</span></span><br><span class="line">        <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (arr[mid] &lt; query) l = mid + <span class="number">1</span>;      <span class="comment">//因为是找起始位置，所以要注意用什么性质</span></span><br><span class="line">            <span class="comment">// 起始位置界满足的性质应该是，它左边的所有元素都严格小于query，所以这里if条件判断的</span></span><br><span class="line">            <span class="comment">// 时候用的是arr[mid] &lt; query</span></span><br><span class="line">            <span class="keyword">else</span> r = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (arr[l] != query)    <span class="comment">// 此时跳出了第一个while，说明l == r，而如果arr[l] != query</span></span><br><span class="line">        <span class="comment">// 说明第一个大于等于query的元素，起始已经大于query了，所以这个数组里就没有这个query</span></span><br><span class="line">        <span class="comment">// 故按照题目说的来输出</span></span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;-1 -1&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>        <span class="comment">//如果进入到了这个else分支，说明上面if不成立，也就是说，这个数组里确实是有</span></span><br><span class="line">        <span class="comment">// query元素的。则可以进一步的来判断query出现的终止位置</span></span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; l &lt;&lt; <span class="string">&#x27; &#x27;</span>;   <span class="comment">// 先输出一下上面已经求出的起始位置</span></span><br><span class="line">            r = n - <span class="number">1</span>;          <span class="comment">// 这里当然可以重新l = 0, r = n - 1；但，既然这里是求终止位置，</span></span><br><span class="line">            <span class="comment">// 终止位置肯定是大于等于起始位置，所以其实没必要把l重新初始化</span></span><br><span class="line">            <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (arr[mid] &gt; query) r = mid - <span class="number">1</span>;  <span class="comment">// 这里因为是在找终止位置，而终止位置的性质</span></span><br><span class="line">                <span class="comment">// 是，它右边的元素一定严格大于query，故此处的条件是arr[mid] &gt; query</span></span><br><span class="line">                <span class="comment">// 而根据模板，当l = mid时，上面求mid的时候需要+1，以免出现死循环</span></span><br><span class="line">                <span class="keyword">else</span> l = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; r &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-2-2-浮点数二分"><a href="#3-2-2-浮点数二分" class="headerlink" title="3.2.2.浮点数二分"></a>3.2.2.浮点数二分</h3><h4 id="这种情况，我们一般要做的就是在一个区间里，去逼近某个数，这个数可能不能直接求出来。例如，求某个数的三次方根。这个就简单多了，不需要考虑什么边界情况。只需要保证单调性即可。还是以上面提到的三次方根为例。开三次方的函数显然是单调递增的。直接看代码就能懂了"><a href="#这种情况，我们一般要做的就是在一个区间里，去逼近某个数，这个数可能不能直接求出来。例如，求某个数的三次方根。这个就简单多了，不需要考虑什么边界情况。只需要保证单调性即可。还是以上面提到的三次方根为例。开三次方的函数显然是单调递增的。直接看代码就能懂了" class="headerlink" title="这种情况，我们一般要做的就是在一个区间里，去逼近某个数，这个数可能不能直接求出来。例如，求某个数的三次方根。这个就简单多了，不需要考虑什么边界情况。只需要保证单调性即可。还是以上面提到的三次方根为例。开三次方的函数显然是单调递增的。直接看代码就能懂了"></a>这种情况，我们一般要做的就是在一个区间里，去逼近某个数，这个数可能不能直接求出来。例如，求某个数的三次方根。这个就简单多了，不需要考虑什么边界情况。只需要保证单调性即可。还是以上面提到的三次方根为例。开三次方的函数显然是单调递增的。直接看代码就能懂了</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="type">double</span> l = <span class="number">-10000</span>, r = <span class="number">10000</span>;</span><br><span class="line">    <span class="keyword">while</span> (r - l &gt; <span class="number">1e-8</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">double</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (mid * mid * mid &lt; n) l = mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (mid * mid * mid &gt; n) r = mid;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; fixed &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">6</span>);</span><br><span class="line">            cout &lt;&lt; mid;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; fixed &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">6</span>);</span><br><span class="line">    cout &lt;&lt; r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="built_in">float</span>(<span class="built_in">input</span>())</span><br><span class="line"><span class="comment"># 这里初始化的时候，如果不带.0，就默认l和r都是整数，于是后面while循环中计算mid的时候都是整数的除法，相当于</span></span><br><span class="line"><span class="comment"># (l + r) // 2    这会导致，后面当l和r只差1的时候，(l + r) // 2一直是l，所以l，r区间一直不变，且长度一直为</span></span><br><span class="line"><span class="comment"># 1，而我们跳出while循环的条件是区间长度小于等于1e-8，所以一直满足不了这个条件，死循环了，故TLE</span></span><br><span class="line"><span class="comment"># 带上.0以后，就默认l和r都是浮点数，后面的除2就是正常的除2，能得到精确的小数结果，所以没问题了</span></span><br><span class="line">l, r = -<span class="number">10000.0</span>, <span class="number">10000.0</span></span><br><span class="line"><span class="keyword">while</span> r - l &gt; <span class="number">1e-8</span>:</span><br><span class="line">    mid = (l + r) / <span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> mid ** <span class="number">3</span> &gt; n:</span><br><span class="line">        r = mid</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        l = mid</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&#123;:.6f&#125;&quot;</span>.<span class="built_in">format</span>(l))</span><br></pre></td></tr></table></figure>
<h4 id="顺带说明一下python中的-format-f-string的用法。-format是python的一种字符串格式化的一种语法（也是比较老的一种，先于f-string出现）"><a href="#顺带说明一下python中的-format-f-string的用法。-format是python的一种字符串格式化的一种语法（也是比较老的一种，先于f-string出现）" class="headerlink" title="顺带说明一下python中的.format&#x2F;f-string的用法。.format是python的一种字符串格式化的一种语法（也是比较老的一种，先于f-string出现）"></a>顺带说明一下python中的.format&#x2F;f-string的用法。.format是python的一种字符串格式化的一种语法（也是比较老的一种，先于f-string出现）</h4><h4 id="以上面用到的-6f-为例。-是占位符，-是一个起始说明符，它后面就是我们期望的格式。而落回到这里，”-6f”就是我们希望的格式，”-”是精度指示符，”6”代表要保留的小数位数，所以这里”-6f”就代表我们期望的格式是保留6位小数"><a href="#以上面用到的-6f-为例。-是占位符，-是一个起始说明符，它后面就是我们期望的格式。而落回到这里，”-6f”就是我们希望的格式，”-”是精度指示符，”6”代表要保留的小数位数，所以这里”-6f”就代表我们期望的格式是保留6位小数" class="headerlink" title="以上面用到的{:.6f}为例。{}是占位符，:是一个起始说明符，它后面就是我们期望的格式。而落回到这里，”.6f”就是我们希望的格式，”.”是精度指示符，”6”代表要保留的小数位数，所以这里”.6f”就代表我们期望的格式是保留6位小数"></a>以上面用到的{:.6f}为例。{}是占位符，:是一个起始说明符，它后面就是我们期望的格式。而落回到这里，”.6f”就是我们希望的格式，”.”是精度指示符，”6”代表要保留的小数位数，所以这里”.6f”就代表我们期望的格式是保留6位小数</h4><h4 id="至于f-string，它是在python3-6之后才出现的，也是用于控制字符串格式的。它相比于-format，特点就是更加简洁。在此处，如果我们还是希望输出保留6位小数，用f-string，则可以这样表示：f-l-6f-。这里我们直接把要输出的变量l放到-里面，至于”-”和”-6f”的用法和功能，则是和上面一样"><a href="#至于f-string，它是在python3-6之后才出现的，也是用于控制字符串格式的。它相比于-format，特点就是更加简洁。在此处，如果我们还是希望输出保留6位小数，用f-string，则可以这样表示：f-l-6f-。这里我们直接把要输出的变量l放到-里面，至于”-”和”-6f”的用法和功能，则是和上面一样" class="headerlink" title="至于f-string，它是在python3.6之后才出现的，也是用于控制字符串格式的。它相比于.format，特点就是更加简洁。在此处，如果我们还是希望输出保留6位小数，用f-string，则可以这样表示：f{l:.6f}。这里我们直接把要输出的变量l放到{}里面，至于”:”和”.6f”的用法和功能，则是和上面一样"></a>至于f-string，它是在python3.6之后才出现的，也是用于控制字符串格式的。它相比于.format，特点就是更加简洁。在此处，如果我们还是希望输出保留6位小数，用f-string，则可以这样表示：f{l:.6f}。这里我们直接把要输出的变量l放到{}里面，至于”:”和”.6f”的用法和功能，则是和上面一样</h4>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://gitookie.github.io/gitookie/2025/02/03/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/gitookie/images/avatar.gif">
      <meta itemprop="name" content="bluemouse">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bluemouse's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/gitookie/2025/02/03/hello-world/" class="post-title-link" itemprop="url">Hello World</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posté le</span>

              <time title="Article créé le: 2025-02-03 17:28:21" itemprop="dateCreated datePublished" datetime="2025-02-03T17:28:21+08:00">2025-02-03</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table Des Matières
        </li>
        <li class="sidebar-nav-overview">
          Aperçu
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">bluemouse</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/gitookie/archives/">
        
          <span class="site-state-item-count">3</span>
          <span class="site-state-item-name">articles</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">bluemouse</span>
</div>
  <div class="powered-by">Propulsé par <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/gitookie/lib/anime.min.js"></script>
  <script src="/gitookie/lib/velocity/velocity.min.js"></script>
  <script src="/gitookie/lib/velocity/velocity.ui.min.js"></script>

<script src="/gitookie/js/utils.js"></script>

<script src="/gitookie/js/motion.js"></script>


<script src="/gitookie/js/schemes/muse.js"></script>


<script src="/gitookie/js/next-boot.js"></script>




  















  

  

</body>
</html>
