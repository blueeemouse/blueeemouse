<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="1.快速排序1.1.核心思想：分治思想1.2.步骤：1.2.1.对于一个给定的数组，选定一个中间值x（理论上来说，选哪个都行，但后面的代码需要注意相应的搭配，否则会陷入死循环。后面具体讲），常见的就是选数组的左边&#x2F;右边&#x2F;中间值&#x2F;随机选1.2.2.调整区间：这一步的目的是，调整数组，使得数组的左边部分的元素全都小于等于中间值x，右边部分的元素全都大于等于x（此时，一定有">
<meta property="og:type" content="article">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="https://gitookie.github.io/gitookie/2025/02/03/chap1.%E7%AC%AC%E4%B8%80%E8%AE%B2%20%20%E5%BF%AB%E6%8E%92%E5%92%8C%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E5%92%8C%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="1.快速排序1.1.核心思想：分治思想1.2.步骤：1.2.1.对于一个给定的数组，选定一个中间值x（理论上来说，选哪个都行，但后面的代码需要注意相应的搭配，否则会陷入死循环。后面具体讲），常见的就是选数组的左边&#x2F;右边&#x2F;中间值&#x2F;随机选1.2.2.调整区间：这一步的目的是，调整数组，使得数组的左边部分的元素全都小于等于中间值x，右边部分的元素全都大于等于x（此时，一定有">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2025-02-03T09:36:57.625Z">
<meta property="article:modified_time" content="2025-02-01T03:33:14.051Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/gitookie/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/gitookie/favicon.png">
  
  
  
<link rel="stylesheet" href="/gitookie/css/style.css">

  
    
<link rel="stylesheet" href="/gitookie/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/gitookie/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/gitookie/">Home</a>
        
          <a class="main-nav-link" href="/gitookie/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/gitookie/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://gitookie.github.io/gitookie"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-chap1.第一讲  快排和归并排序和二分查找" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/gitookie/2025/02/03/chap1.%E7%AC%AC%E4%B8%80%E8%AE%B2%20%20%E5%BF%AB%E6%8E%92%E5%92%8C%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E5%92%8C%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/" class="article-date">
  <time class="dt-published" datetime="2025-02-03T09:36:57.625Z" itemprop="datePublished">2025-02-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="1-快速排序"><a href="#1-快速排序" class="headerlink" title="1.快速排序"></a>1.快速排序</h1><h2 id="1-1-核心思想：分治思想"><a href="#1-1-核心思想：分治思想" class="headerlink" title="1.1.核心思想：分治思想"></a>1.1.核心思想：分治思想</h2><h2 id="1-2-步骤："><a href="#1-2-步骤：" class="headerlink" title="1.2.步骤："></a>1.2.步骤：</h2><h3 id="1-2-1-对于一个给定的数组，选定一个中间值x（理论上来说，选哪个都行，但后面的代码需要注意相应的搭配，否则会陷入死循环。后面具体讲），常见的就是选数组的左边-右边-中间值-随机选"><a href="#1-2-1-对于一个给定的数组，选定一个中间值x（理论上来说，选哪个都行，但后面的代码需要注意相应的搭配，否则会陷入死循环。后面具体讲），常见的就是选数组的左边-右边-中间值-随机选" class="headerlink" title="1.2.1.对于一个给定的数组，选定一个中间值x（理论上来说，选哪个都行，但后面的代码需要注意相应的搭配，否则会陷入死循环。后面具体讲），常见的就是选数组的左边&#x2F;右边&#x2F;中间值&#x2F;随机选"></a>1.2.1.对于一个给定的数组，选定一个中间值x（理论上来说，选哪个都行，但后面的代码需要注意相应的搭配，否则会陷入死循环。后面具体讲），常见的就是选数组的左边&#x2F;右边&#x2F;中间值&#x2F;随机选</h3><h3 id="1-2-2-调整区间：这一步的目的是，调整数组，使得数组的左边部分的元素全都小于等于中间值x，右边部分的元素全都大于等于x（此时，一定有右边的元素大于等于左边的元素。这是快排正确性的保证）"><a href="#1-2-2-调整区间：这一步的目的是，调整数组，使得数组的左边部分的元素全都小于等于中间值x，右边部分的元素全都大于等于x（此时，一定有右边的元素大于等于左边的元素。这是快排正确性的保证）" class="headerlink" title="1.2.2.调整区间：这一步的目的是，调整数组，使得数组的左边部分的元素全都小于等于中间值x，右边部分的元素全都大于等于x（此时，一定有右边的元素大于等于左边的元素。这是快排正确性的保证）"></a>1.2.2.调整区间：这一步的目的是，调整数组，使得数组的左边部分的元素全都小于等于中间值x，右边部分的元素全都大于等于x（此时，一定有右边的元素大于等于左边的元素。这是快排正确性的保证）</h3><h3 id="1-2-3-递归：对上面的左边和右边部分的子数组也进行1-2-1-1-2-2的操作"><a href="#1-2-3-递归：对上面的左边和右边部分的子数组也进行1-2-1-1-2-2的操作" class="headerlink" title="1.2.3.递归：对上面的左边和右边部分的子数组也进行1.2.1-1.2.2的操作"></a>1.2.3.递归：对上面的左边和右边部分的子数组也进行1.2.1-1.2.2的操作</h3><h3 id="可以看到，核心步骤应该是1-2-2。而关于1-2-2的实现，一个比较简单粗暴的方法是，再开两个数组a，b，然后，从左到右扫描一遍待排序的数组s，如果一个元素小于等于中间值，则放到数组a里，大于中间值，则放到b里。扫描完之后，先把a的元素放回s里，再把b的元素放回s里（放回去的顺序也从左往右即可），就完成了。时间复杂度上，因为要扫描一遍，放回一遍，应该是2N，也就是-O-N-；主要的问题在空间复杂度上，需要再开两个数组，不太好"><a href="#可以看到，核心步骤应该是1-2-2。而关于1-2-2的实现，一个比较简单粗暴的方法是，再开两个数组a，b，然后，从左到右扫描一遍待排序的数组s，如果一个元素小于等于中间值，则放到数组a里，大于中间值，则放到b里。扫描完之后，先把a的元素放回s里，再把b的元素放回s里（放回去的顺序也从左往右即可），就完成了。时间复杂度上，因为要扫描一遍，放回一遍，应该是2N，也就是-O-N-；主要的问题在空间复杂度上，需要再开两个数组，不太好" class="headerlink" title="可以看到，核心步骤应该是1.2.2。而关于1.2.2的实现，一个比较简单粗暴的方法是，再开两个数组a，b，然后，从左到右扫描一遍待排序的数组s，如果一个元素小于等于中间值，则放到数组a里，大于中间值，则放到b里。扫描完之后，先把a的元素放回s里，再把b的元素放回s里（放回去的顺序也从左往右即可），就完成了。时间复杂度上，因为要扫描一遍，放回一遍，应该是2N，也就是$O(N)$；主要的问题在空间复杂度上，需要再开两个数组，不太好"></a>可以看到，核心步骤应该是1.2.2。而关于1.2.2的实现，一个比较简单粗暴的方法是，再开两个数组a，b，然后，从左到右扫描一遍待排序的数组s，如果一个元素小于等于中间值，则放到数组a里，大于中间值，则放到b里。扫描完之后，先把a的元素放回s里，再把b的元素放回s里（放回去的顺序也从左往右即可），就完成了。时间复杂度上，因为要扫描一遍，放回一遍，应该是2N，也就是$O(N)$；主要的问题在空间复杂度上，需要再开两个数组，不太好</h3><h3 id="而我个人的第一想法是，（本质也是一个双指针法）"><a href="#而我个人的第一想法是，（本质也是一个双指针法）" class="headerlink" title="而我个人的第一想法是，（本质也是一个双指针法）"></a>而我个人的第一想法是，（本质也是一个双指针法）</h3><h4 id="给一组双指针，起始分别在s的最左边和最右边。"><a href="#给一组双指针，起始分别在s的最左边和最右边。" class="headerlink" title="给一组双指针，起始分别在s的最左边和最右边。"></a>给一组双指针，起始分别在s的最左边和最右边。</h4><h4 id="左指针从左往右移动，如果当前左指针指向的元素小于等于中间值x，则不动它，继续往右走一格；如果当前左指针指向的元素大于中间值x，则把它和s的右指针指向的元素替换，同时右指针往左走一格，左指针先不动：换过来的新元素如果小于等于x，则左指针往右走一格；如果缓过来的新元素还是大于x，则再让它和右指针指向的元素交换一下（注意，上面已经让右指针往左走一格了），"><a href="#左指针从左往右移动，如果当前左指针指向的元素小于等于中间值x，则不动它，继续往右走一格；如果当前左指针指向的元素大于中间值x，则把它和s的右指针指向的元素替换，同时右指针往左走一格，左指针先不动：换过来的新元素如果小于等于x，则左指针往右走一格；如果缓过来的新元素还是大于x，则再让它和右指针指向的元素交换一下（注意，上面已经让右指针往左走一格了），" class="headerlink" title="左指针从左往右移动，如果当前左指针指向的元素小于等于中间值x，则不动它，继续往右走一格；如果当前左指针指向的元素大于中间值x，则把它和s的右指针指向的元素替换，同时右指针往左走一格，左指针先不动：换过来的新元素如果小于等于x，则左指针往右走一格；如果缓过来的新元素还是大于x，则再让它和右指针指向的元素交换一下（注意，上面已经让右指针往左走一格了），"></a>左指针从左往右移动，如果当前左指针指向的元素小于等于中间值x，则不动它，继续往右走一格；如果当前左指针指向的元素大于中间值x，则把它和s的右指针指向的元素替换，同时右指针往左走一格，左指针先不动：换过来的新元素如果小于等于x，则左指针往右走一格；如果缓过来的新元素还是大于x，则再让它和右指针指向的元素交换一下（注意，上面已经让右指针往左走一格了），</h4><h4 id="然后一直重复上面的判断，直到左指针继续往右走了，或者是右指针一直往左走，走到了与左指针相遇的位置（感觉其实已经很接近给的模板了）"><a href="#然后一直重复上面的判断，直到左指针继续往右走了，或者是右指针一直往左走，走到了与左指针相遇的位置（感觉其实已经很接近给的模板了）" class="headerlink" title="然后一直重复上面的判断，直到左指针继续往右走了，或者是右指针一直往左走，走到了与左指针相遇的位置（感觉其实已经很接近给的模板了）"></a>然后一直重复上面的判断，直到左指针继续往右走了，或者是右指针一直往左走，走到了与左指针相遇的位置（感觉其实已经很接近给的模板了）</h4><h3 id="模板的话，是一个双指针，比我的稍微简洁一点。主要的改进在于，我的方法在遇到左指针元素大于x的时候，一定会和右指针元素交换，且右指针一定往走一格；而模板的方法是，"><a href="#模板的话，是一个双指针，比我的稍微简洁一点。主要的改进在于，我的方法在遇到左指针元素大于x的时候，一定会和右指针元素交换，且右指针一定往走一格；而模板的方法是，" class="headerlink" title="模板的话，是一个双指针，比我的稍微简洁一点。主要的改进在于，我的方法在遇到左指针元素大于x的时候，一定会和右指针元素交换，且右指针一定往走一格；而模板的方法是，"></a>模板的话，是一个双指针，比我的稍微简洁一点。主要的改进在于，我的方法在遇到左指针元素大于x的时候，一定会和右指针元素交换，且右指针一定往走一格；而模板的方法是，</h3><h4 id="如果左指针元素小于x，则符合要求，左指针往右走一格；如果左指针元素大于等于x，则我不动左指针了，去移动右指针：如果右指针元素大于x，也符合要求，则右指针往左走一格；如果右指针元素小于等于x，则现在的情况是：左指针元素大于等于x，右指针元素小于等于x，它们交换一下就刚好符合要求了，故交换左右指针指向的元素。之后继续移动左指针，重复上面的步骤，直至左右指针相遇（或者右指针第一次走到左指针左边-左指针第一次走到右指针右边）。代码模板如下："><a href="#如果左指针元素小于x，则符合要求，左指针往右走一格；如果左指针元素大于等于x，则我不动左指针了，去移动右指针：如果右指针元素大于x，也符合要求，则右指针往左走一格；如果右指针元素小于等于x，则现在的情况是：左指针元素大于等于x，右指针元素小于等于x，它们交换一下就刚好符合要求了，故交换左右指针指向的元素。之后继续移动左指针，重复上面的步骤，直至左右指针相遇（或者右指针第一次走到左指针左边-左指针第一次走到右指针右边）。代码模板如下：" class="headerlink" title="如果左指针元素小于x，则符合要求，左指针往右走一格；如果左指针元素大于等于x，则我不动左指针了，去移动右指针：如果右指针元素大于x，也符合要求，则右指针往左走一格；如果右指针元素小于等于x，则现在的情况是：左指针元素大于等于x，右指针元素小于等于x，它们交换一下就刚好符合要求了，故交换左右指针指向的元素。之后继续移动左指针，重复上面的步骤，直至左右指针相遇（或者右指针第一次走到左指针左边&#x2F;左指针第一次走到右指针右边）。代码模板如下："></a>如果左指针元素小于x，则符合要求，左指针往右走一格；如果左指针元素大于等于x，则我不动左指针了，去移动右指针：如果右指针元素大于x，也符合要求，则右指针往左走一格；如果右指针元素小于等于x，则现在的情况是：左指针元素大于等于x，右指针元素小于等于x，它们交换一下就刚好符合要求了，故交换左右指针指向的元素。之后继续移动左指针，重复上面的步骤，直至左右指针相遇（或者右指针第一次走到左指针左边&#x2F;左指针第一次走到右指针右边）。代码模板如下：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = l - <span class="number">1</span>, j = r + <span class="number">1</span>, x = q[l + r &gt;&gt; <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span> i ++ ; <span class="keyword">while</span> (q[i] &lt; x);</span><br><span class="line">        <span class="keyword">do</span> j -- ; <span class="keyword">while</span> (q[j] &gt; x);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) <span class="built_in">swap</span>(q[i], q[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">quick_sort</span>(q, l, j), <span class="built_in">quick_sort</span>(q, j + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：yxc</span><br><span class="line">链接：https:<span class="comment">//www.acwing.com/blog/content/277/</span></span><br><span class="line">来源：AcWing</span><br></pre></td></tr></table></figure>
<h2 id="问题：模板变化的原理是？就是说，如果后面递归的时候，用i来划分边界，quick-sort-q-l-i-1-quick-sort-q-i-r-，则上面选枢纽元的时候不能选q-l-？类似的，用j来划分边界的时候，枢纽元就不能取q-r-？为什么？"><a href="#问题：模板变化的原理是？就是说，如果后面递归的时候，用i来划分边界，quick-sort-q-l-i-1-quick-sort-q-i-r-，则上面选枢纽元的时候不能选q-l-？类似的，用j来划分边界的时候，枢纽元就不能取q-r-？为什么？" class="headerlink" title="问题：模板变化的原理是？就是说，如果后面递归的时候，用i来划分边界，quick_sort(q, l, i - 1), quick_sort(q, i, r)，则上面选枢纽元的时候不能选q[l]？类似的，用j来划分边界的时候，枢纽元就不能取q[r]？为什么？"></a>问题：模板变化的原理是？就是说，如果后面递归的时候，用i来划分边界，quick_sort(q, l, i - 1), quick_sort(q, i, r)，则上面选枢纽元的时候不能选q[l]？类似的，用j来划分边界的时候，枢纽元就不能取q[r]？为什么？</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误典范一：两个子while循环的判断条件中，带上了“等于”</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> pivot = arr[mid];</span><br><span class="line">    <span class="comment">// int i = l - 1, j = r + 1;</span></span><br><span class="line">    <span class="type">int</span> i = l, j = r;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; i &lt;&lt; j;</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; i &lt;&lt; j;</span></span><br><span class="line">        <span class="comment">// i++;        // 看起来，似乎不在里面的两个while循环前移动指针，也不会有什么问题，因为：</span></span><br><span class="line">        <span class="comment">// 一个大的while循环结束之后，左右指针指向的元素应该都是符合要求的（左指针元素大于等于</span></span><br><span class="line">        <span class="comment">// pivot，右指针元素小于等于pivot）。此时开始一个新的while大循环，并不会有什么问题，在</span></span><br><span class="line">        <span class="comment">// 两个小的while循环中，应该会正常的通过，然后相应移动指针。。。</span></span><br><span class="line">        <span class="comment">// 但问题就是出在我们认为的“应该会正常通过”。事实上，一个大循环完了，确实左右指针的元素</span></span><br><span class="line">        <span class="comment">// 符合要求，但未必就能进到两个小的while循环里。</span></span><br><span class="line">        <span class="comment">// 这是因为，如果某个时刻出现：左右指针指向</span></span><br><span class="line">        <span class="comment">// 的元素都是pivot，则两个while都不会执行，swap也不会产生什么效果，然后再进到新的</span></span><br><span class="line">        <span class="comment">// while(i &lt; j)的循环中时，也是如此。就一直卡这里了，所以会超时</span></span><br><span class="line">        <span class="comment">// 说到底，其实是因为我们的两个子循环的判断条件导致的：都是严格的小于/大于，而不是</span></span><br><span class="line">        <span class="comment">// 小于等于/大于等于</span></span><br><span class="line">        <span class="keyword">while</span> (arr[i] &lt;= pivot &amp;&amp; i &lt; j) i++;       <span class="comment">// 像现在这样，判断条件中加上等于的话，</span></span><br><span class="line">        <span class="comment">// 看起来没什么问题，可如果出现一个数组里所有元素相等的极端情况的话，最终i就会变成r，</span></span><br><span class="line">        <span class="comment">// j也还是r不变，则下面的两个递归调用中，第一个就和现在的是一样的了，所以会一直递归调用</span></span><br><span class="line">        <span class="comment">// 陷入死循环</span></span><br><span class="line">        <span class="comment">// cout &lt;&lt; i;</span></span><br><span class="line">        <span class="comment">// j--;</span></span><br><span class="line">        <span class="keyword">while</span> (arr[j] &gt;= pivot &amp;&amp; j &gt; i) j--;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; j;</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) <span class="built_in">swap</span>(arr[i], arr[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">quick_sort</span>(arr, l, j);</span><br><span class="line">    <span class="built_in">quick_sort</span>(arr, j + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误典范二：在两个子while循环中不先移动一下指针</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> pivot = arr[mid];</span><br><span class="line">    <span class="comment">// int i = l - 1, j = r + 1;</span></span><br><span class="line">    <span class="type">int</span> i = l, j = r;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; i &lt;&lt; j;</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; i &lt;&lt; j;</span></span><br><span class="line">        <span class="comment">// i++;        // 看起来，似乎不在里面的两个while循环前移动指针，也不会有什么问题，因为：</span></span><br><span class="line">        <span class="comment">// 一个大的while循环结束之后，左右指针指向的元素应该都是符合要求的（左指针元素大于等于</span></span><br><span class="line">        <span class="comment">// pivot，右指针元素小于等于pivot）。此时开始一个新的while大循环，并不会有什么问题，在</span></span><br><span class="line">        <span class="comment">// 两个小的while循环中，应该会正常的通过，然后相应移动指针。。。</span></span><br><span class="line">        <span class="comment">// 但问题就是出在我们认为的“应该会正常通过”。事实上，一个大循环完了，确实左右指针的元素</span></span><br><span class="line">        <span class="comment">// 符合要求，但未必就能进到两个小的while循环里。</span></span><br><span class="line">        <span class="comment">// 这是因为，如果某个时刻出现：左右指针指向</span></span><br><span class="line">        <span class="comment">// 的元素都是pivot，则两个while都不会执行，swap也不会产生什么效果，然后再进到新的</span></span><br><span class="line">        <span class="comment">// while(i &lt; j)的循环中时，也是如此。就一直卡这里了，所以会超时</span></span><br><span class="line">        <span class="comment">// 说到底，其实是因为我们的两个子循环的判断条件导致的：都是严格的小于/大于，而不是</span></span><br><span class="line">        <span class="comment">// 小于等于/大于等于</span></span><br><span class="line">        <span class="keyword">while</span> (arr[i] &lt; pivot) i++;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; i;</span></span><br><span class="line">        <span class="comment">// j--;</span></span><br><span class="line">        <span class="keyword">while</span> (arr[j] &gt; pivot) j--;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; j;</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) <span class="built_in">swap</span>(arr[i], arr[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">quick_sort</span>(arr, l, j);</span><br><span class="line">    <span class="built_in">quick_sort</span>(arr, j + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="2-归并排序"><a href="#2-归并排序" class="headerlink" title="2.归并排序"></a>2.归并排序</h1><h2 id="1-1-核心思想：分治思想-1"><a href="#1-1-核心思想：分治思想-1" class="headerlink" title="1.1.核心思想：分治思想"></a>1.1.核心思想：分治思想</h2><h2 id="1-2-大致流程："><a href="#1-2-大致流程：" class="headerlink" title="1.2.大致流程："></a>1.2.大致流程：</h2><h3 id="这里也会选一个类似枢纽元的元素，但是是固定选取为中间的那个元素。我们的目标是把左半边和右半边的部分元素都排好序，这样左右半边都是一个有序数组，最后就可以用一个双指针法进行合并，从而得到最终结果。显然，这里的关键在于如何快速高效地把左半边和右半边排好序，以及如何合并结果。下面是详细步骤"><a href="#这里也会选一个类似枢纽元的元素，但是是固定选取为中间的那个元素。我们的目标是把左半边和右半边的部分元素都排好序，这样左右半边都是一个有序数组，最后就可以用一个双指针法进行合并，从而得到最终结果。显然，这里的关键在于如何快速高效地把左半边和右半边排好序，以及如何合并结果。下面是详细步骤" class="headerlink" title="这里也会选一个类似枢纽元的元素，但是是固定选取为中间的那个元素。我们的目标是把左半边和右半边的部分元素都排好序，这样左右半边都是一个有序数组，最后就可以用一个双指针法进行合并，从而得到最终结果。显然，这里的关键在于如何快速高效地把左半边和右半边排好序，以及如何合并结果。下面是详细步骤"></a>这里也会选一个类似枢纽元的元素，但是是固定选取为中间的那个元素。我们的目标是把左半边和右半边的部分元素都排好序，这样左右半边都是一个有序数组，最后就可以用一个双指针法进行合并，从而得到最终结果。显然，这里的关键在于如何快速高效地把左半边和右半边排好序，以及如何合并结果。下面是详细步骤</h3><h2 id="1-3-步骤："><a href="#1-3-步骤：" class="headerlink" title="1.3.步骤："></a>1.3.步骤：</h2><h3 id="1-3-1-先明确一下递归结束的条件：若当前数组只有一个元素，或没有元素，则递归结束，return；否则还需继续进行递归，那么就选择中间元素，就是字面意思地进行选择"><a href="#1-3-1-先明确一下递归结束的条件：若当前数组只有一个元素，或没有元素，则递归结束，return；否则还需继续进行递归，那么就选择中间元素，就是字面意思地进行选择" class="headerlink" title="1.3.1.先明确一下递归结束的条件：若当前数组只有一个元素，或没有元素，则递归结束，return；否则还需继续进行递归，那么就选择中间元素，就是字面意思地进行选择"></a>1.3.1.先明确一下递归结束的条件：若当前数组只有一个元素，或没有元素，则递归结束，return；否则还需继续进行递归，那么就选择中间元素，就是字面意思地进行选择</h3><h3 id="1-3-2-递归地对左右半边调用归并排序算法的函数（这里回答了上面提到的，如何快速高效地把左半边和右半边排好序）（理解上，我们可以认为，递归排序算法已经写好，对左半边和右半边调用这个函数就可以实现排序）"><a href="#1-3-2-递归地对左右半边调用归并排序算法的函数（这里回答了上面提到的，如何快速高效地把左半边和右半边排好序）（理解上，我们可以认为，递归排序算法已经写好，对左半边和右半边调用这个函数就可以实现排序）" class="headerlink" title="1.3.2.递归地对左右半边调用归并排序算法的函数（这里回答了上面提到的，如何快速高效地把左半边和右半边排好序）（理解上，我们可以认为，递归排序算法已经写好，对左半边和右半边调用这个函数就可以实现排序）"></a>1.3.2.递归地对左右半边调用归并排序算法的函数（这里回答了上面提到的，如何快速高效地把左半边和右半边排好序）（理解上，我们可以认为，递归排序算法已经写好，对左半边和右半边调用这个函数就可以实现排序）</h3><h3 id="1-3-3-合并。现在已经得到了左右半边两个有序的数组，就要进行合并了。原理上是很简单的。初始化两个指针，分别指向左半边的开始和右半边的开始，然后开始移动。比较当前两个指针的元素，指向元素较小的那个指针，把它指向的那个元素存到一个中间数组里（往中间数组里存储，也是从左往右的），并把指针往右移动一格；如果遇到当前双指针指向的元素相同的情况，那么我们一般是选择把左半边的那个指针的元素存到中间数组，并移动左半边的那个指针（因为这样可以保证归并排序是稳定的。下面会细讲。反正这个影响不大）。如此一直重复，直至有某个指针第一次到达了它的终点。此时若另一个指针还没到终点，则把它当前指向的元素及后面所有的元素都一并复制到中间数组里。至此，合并完成"><a href="#1-3-3-合并。现在已经得到了左右半边两个有序的数组，就要进行合并了。原理上是很简单的。初始化两个指针，分别指向左半边的开始和右半边的开始，然后开始移动。比较当前两个指针的元素，指向元素较小的那个指针，把它指向的那个元素存到一个中间数组里（往中间数组里存储，也是从左往右的），并把指针往右移动一格；如果遇到当前双指针指向的元素相同的情况，那么我们一般是选择把左半边的那个指针的元素存到中间数组，并移动左半边的那个指针（因为这样可以保证归并排序是稳定的。下面会细讲。反正这个影响不大）。如此一直重复，直至有某个指针第一次到达了它的终点。此时若另一个指针还没到终点，则把它当前指向的元素及后面所有的元素都一并复制到中间数组里。至此，合并完成" class="headerlink" title="1.3.3.合并。现在已经得到了左右半边两个有序的数组，就要进行合并了。原理上是很简单的。初始化两个指针，分别指向左半边的开始和右半边的开始，然后开始移动。比较当前两个指针的元素，指向元素较小的那个指针，把它指向的那个元素存到一个中间数组里（往中间数组里存储，也是从左往右的），并把指针往右移动一格；如果遇到当前双指针指向的元素相同的情况，那么我们一般是选择把左半边的那个指针的元素存到中间数组，并移动左半边的那个指针（因为这样可以保证归并排序是稳定的。下面会细讲。反正这个影响不大）。如此一直重复，直至有某个指针第一次到达了它的终点。此时若另一个指针还没到终点，则把它当前指向的元素及后面所有的元素都一并复制到中间数组里。至此，合并完成"></a>1.3.3.合并。现在已经得到了左右半边两个有序的数组，就要进行合并了。原理上是很简单的。<br>初始化两个指针，分别指向左半边的开始和右半边的开始，然后开始移动。比较当前两个指针的元素，指向元素较小的那个指针，把它指向的那个元素存到一个中间数组里（往中间数组里存储，也是从左往右的），并把指针往右移动一格；如果遇到当前双指针指向的元素相同的情况，那么我们一般是选择把左半边的那个指针的元素存到中间数组，并移动左半边的那个指针（因为这样可以保证归并排序是稳定的。下面会细讲。反正这个影响不大）。<br>如此一直重复，直至有某个指针第一次到达了它的终点。此时若另一个指针还没到终点，则把它当前指向的元素及后面所有的元素都一并复制到中间数组里。至此，合并完成</h3><h2 id="1-4-代码模板"><a href="#1-4-代码模板" class="headerlink" title="1.4.代码模板"></a>1.4.代码模板</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">merge_sort</span>(q, l, mid);</span><br><span class="line">    <span class="built_in">merge_sort</span>(q, mid + <span class="number">1</span>, r);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>, i = l, j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r)</span><br><span class="line">        <span class="keyword">if</span> (q[i] &lt;= q[j]) tmp[k ++ ] = q[i ++ ];</span><br><span class="line">        <span class="keyword">else</span> tmp[k ++ ] = q[j ++ ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) tmp[k ++ ] = q[i ++ ];</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= r) tmp[k ++ ] = q[j ++ ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = l, j = <span class="number">0</span>; i &lt;= r; i ++, j ++ ) q[i] = tmp[j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：yxc</span><br><span class="line">链接：https:<span class="comment">//www.acwing.com/blog/content/277/</span></span><br><span class="line">来源：AcWing</span><br></pre></td></tr></table></figure>
<h1 id="3-二分查找"><a href="#3-二分查找" class="headerlink" title="3.二分查找"></a>3.二分查找</h1><h2 id="3-0-概述：二分查找，顾名思义，是一种用来查找指定元素的算法。它大致有两种，一种是整数二分，即在一个有序的整数序列中查找指定元素；一种是浮点数二分，或者说实数二分，即在一个有序的实数区间里查找指定元素（当然一般找到的可能是一个近似值）。比较麻烦的是整数二分，因为它需要一些边界条件的判断。而实数二分就比较简单了，没有什么边界问题"><a href="#3-0-概述：二分查找，顾名思义，是一种用来查找指定元素的算法。它大致有两种，一种是整数二分，即在一个有序的整数序列中查找指定元素；一种是浮点数二分，或者说实数二分，即在一个有序的实数区间里查找指定元素（当然一般找到的可能是一个近似值）。比较麻烦的是整数二分，因为它需要一些边界条件的判断。而实数二分就比较简单了，没有什么边界问题" class="headerlink" title="3.0.概述：二分查找，顾名思义，是一种用来查找指定元素的算法。它大致有两种，一种是整数二分，即在一个有序的整数序列中查找指定元素；一种是浮点数二分，或者说实数二分，即在一个有序的实数区间里查找指定元素（当然一般找到的可能是一个近似值）。比较麻烦的是整数二分，因为它需要一些边界条件的判断。而实数二分就比较简单了，没有什么边界问题"></a>3.0.概述：二分查找，顾名思义，是一种用来查找指定元素的算法。它大致有两种，一种是整数二分，即在一个有序的整数序列中查找指定元素；一种是浮点数二分，或者说实数二分，即在一个有序的实数区间里查找指定元素（当然一般找到的可能是一个近似值）。比较麻烦的是整数二分，因为它需要一些边界条件的判断。而实数二分就比较简单了，没有什么边界问题</h2><h2 id="3-1-核心思想：需要澄清的一点是，单调性是有利于二分查找的，但并不意味着要用二分查找就一定要求输入满足单调性。更抽象地说，二分，它“分”的依据是，某个元素，如果它满足一定性质，则它的左边或它的右边，一定会全都满足某种性质。单调性是其中的一种特例。譬如，一个整数序列，它是单调递增的。我们想找元素x，如果当前元素a它小于x，根据单调性，a右边的所有元素应该都大于等于a（这就是我们说的，它的左边或它的右边，一定会全都满足某种性质），因此x也应该在a的右边。由此我们就缩小了查找x的范围了"><a href="#3-1-核心思想：需要澄清的一点是，单调性是有利于二分查找的，但并不意味着要用二分查找就一定要求输入满足单调性。更抽象地说，二分，它“分”的依据是，某个元素，如果它满足一定性质，则它的左边或它的右边，一定会全都满足某种性质。单调性是其中的一种特例。譬如，一个整数序列，它是单调递增的。我们想找元素x，如果当前元素a它小于x，根据单调性，a右边的所有元素应该都大于等于a（这就是我们说的，它的左边或它的右边，一定会全都满足某种性质），因此x也应该在a的右边。由此我们就缩小了查找x的范围了" class="headerlink" title="3.1.核心思想：需要澄清的一点是，单调性是有利于二分查找的，但并不意味着要用二分查找就一定要求输入满足单调性。更抽象地说，二分，它“分”的依据是，某个元素，如果它满足一定性质，则它的左边或它的右边，一定会全都满足某种性质。单调性是其中的一种特例。譬如，一个整数序列，它是单调递增的。我们想找元素x，如果当前元素a它小于x，根据单调性，a右边的所有元素应该都大于等于a（这就是我们说的，它的左边或它的右边，一定会全都满足某种性质），因此x也应该在a的右边。由此我们就缩小了查找x的范围了"></a>3.1.核心思想：需要澄清的一点是，单调性是有利于二分查找的，但并不意味着要用二分查找就一定要求输入满足单调性。更抽象地说，二分，它“分”的依据是，某个元素，如果它满足一定性质，则它的左边或它的右边，一定会全都满足某种性质。单调性是其中的一种特例。譬如，一个整数序列，它是单调递增的。我们想找元素x，如果当前元素a它小于x，根据单调性，a右边的所有元素应该都大于等于a（这就是我们说的，它的左边或它的右边，一定会全都满足某种性质），因此x也应该在a的右边。由此我们就缩小了查找x的范围了</h2><h2 id="3-2-具体步骤："><a href="#3-2-具体步骤：" class="headerlink" title="3.2.具体步骤："></a>3.2.具体步骤：</h2><h3 id="3-2-1-整数二分"><a href="#3-2-1-整数二分" class="headerlink" title="3.2.1.整数二分"></a>3.2.1.整数二分</h3><h4 id="比方说，我们要在一个升序排列的数组里找到一个指定元素x，通常的思路是先找到中间那个元素mid，看看它是比x大还是小：如果它比x大，则x一定在左半边；反之，x在右半边。在缩小的那半边里继续这一套流程，直至区间里只有一个元素，这就是我们查找的结果上面的内容里有两点需要注意，一个是中间元素mid怎么找。看起来无关紧要，但代码实现上的时候，这里会影响到后面的代码实现，且很容易出错；第二点是“查找结果”，我们的整数二分是一定会有一个结果的，但本身这个待查找元素x未必就在数组里。也就是说，即使数组里没有这个元素，我们用朴素的整数二分，不做其它的处理，还是会得到一个“伪答案”。所以实际看题目，如果题目说查找元素未必存在，就需要多一些处理逻辑"><a href="#比方说，我们要在一个升序排列的数组里找到一个指定元素x，通常的思路是先找到中间那个元素mid，看看它是比x大还是小：如果它比x大，则x一定在左半边；反之，x在右半边。在缩小的那半边里继续这一套流程，直至区间里只有一个元素，这就是我们查找的结果上面的内容里有两点需要注意，一个是中间元素mid怎么找。看起来无关紧要，但代码实现上的时候，这里会影响到后面的代码实现，且很容易出错；第二点是“查找结果”，我们的整数二分是一定会有一个结果的，但本身这个待查找元素x未必就在数组里。也就是说，即使数组里没有这个元素，我们用朴素的整数二分，不做其它的处理，还是会得到一个“伪答案”。所以实际看题目，如果题目说查找元素未必存在，就需要多一些处理逻辑" class="headerlink" title="比方说，我们要在一个升序排列的数组里找到一个指定元素x，通常的思路是先找到中间那个元素mid，看看它是比x大还是小：如果它比x大，则x一定在左半边；反之，x在右半边。在缩小的那半边里继续这一套流程，直至区间里只有一个元素，这就是我们查找的结果上面的内容里有两点需要注意，一个是中间元素mid怎么找。看起来无关紧要，但代码实现上的时候，这里会影响到后面的代码实现，且很容易出错；第二点是“查找结果”，我们的整数二分是一定会有一个结果的，但本身这个待查找元素x未必就在数组里。也就是说，即使数组里没有这个元素，我们用朴素的整数二分，不做其它的处理，还是会得到一个“伪答案”。所以实际看题目，如果题目说查找元素未必存在，就需要多一些处理逻辑"></a>比方说，我们要在一个升序排列的数组里找到一个指定元素x，通常的思路是先找到中间那个元素mid，看看它是比x大还是小：如果它比x大，则x一定在左半边；反之，x在右半边。在缩小的那半边里继续这一套流程，直至区间里只有一个元素，这就是我们查找的结果<br>上面的内容里有两点需要注意，一个是中间元素mid怎么找。看起来无关紧要，但代码实现上的时候，这里会影响到后面的代码实现，且很容易出错；第二点是“查找结果”，我们的整数二分是一定会有一个结果的，但本身这个待查找元素x未必就在数组里。也就是说，即使数组里没有这个元素，我们用朴素的整数二分，不做其它的处理，还是会得到一个“伪答案”。所以实际看题目，如果题目说查找元素未必存在，就需要多一些处理逻辑</h4><h4 id="代码模板"><a href="#代码模板" class="headerlink" title="代码模板"></a>代码模板</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="comment">/* ... */</span>&#125; <span class="comment">// 检查x是否满足某种性质</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bsearch_1</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) r = mid;    <span class="comment">// check()判断mid是否满足性质</span></span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bsearch_2</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) l = mid;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：yxc</span><br><span class="line">链接：https:<span class="comment">//www.acwing.com/blog/content/277/</span></span><br><span class="line">来源：AcWing</span><br></pre></td></tr></table></figure>
<h4 id="对上面的代码简单说明一下。check函数其实是一种广义的函数，它未必就是比大小，需要看题目要求然后上面是实现了两种二分查找。可以看到，两种方法的mid取法是不一样的，且影响到后面区间的缩减。实际我们应用的时候，不需要死记硬背套这两个模板。比较自然的思路是，我们会依据题目条件，先写好一个check，并把区间缩减的方式写好。之后，我们可以再去更改mid的取法。而之所以会有两种不同的取法，主要是因为，在第二种方法中，有if-check-mid-l-mid-这一行。如果mid还是取为l-r-1，则当l仅比r小1的时候，如果check-mid-成立了，l-mid，而此时mid还是l，就陷入了死循环了。所以必须要加上一个1"><a href="#对上面的代码简单说明一下。check函数其实是一种广义的函数，它未必就是比大小，需要看题目要求然后上面是实现了两种二分查找。可以看到，两种方法的mid取法是不一样的，且影响到后面区间的缩减。实际我们应用的时候，不需要死记硬背套这两个模板。比较自然的思路是，我们会依据题目条件，先写好一个check，并把区间缩减的方式写好。之后，我们可以再去更改mid的取法。而之所以会有两种不同的取法，主要是因为，在第二种方法中，有if-check-mid-l-mid-这一行。如果mid还是取为l-r-1，则当l仅比r小1的时候，如果check-mid-成立了，l-mid，而此时mid还是l，就陷入了死循环了。所以必须要加上一个1" class="headerlink" title="对上面的代码简单说明一下。check函数其实是一种广义的函数，它未必就是比大小，需要看题目要求然后上面是实现了两种二分查找。可以看到，两种方法的mid取法是不一样的，且影响到后面区间的缩减。实际我们应用的时候，不需要死记硬背套这两个模板。比较自然的思路是，我们会依据题目条件，先写好一个check，并把区间缩减的方式写好。之后，我们可以再去更改mid的取法。而之所以会有两种不同的取法，主要是因为，在第二种方法中，有if (check(mid)) l = mid;这一行。如果mid还是取为l + r &gt;&gt; 1，则当l仅比r小1的时候，如果check(mid)成立了，l&#x3D;mid，而此时mid还是l，就陷入了死循环了。所以必须要加上一个1"></a>对上面的代码简单说明一下。check函数其实是一种广义的函数，它未必就是比大小，需要看题目要求<br>然后上面是实现了两种二分查找。可以看到，两种方法的mid取法是不一样的，且影响到后面区间的缩减。实际我们应用的时候，不需要死记硬背套这两个模板。比较自然的思路是，我们会依据题目条件，先写好一个check，并把区间缩减的方式写好。之后，我们可以再去更改mid的取法。而之所以会有两种不同的取法，主要是因为，在第二种方法中，有<code>if (check(mid)) l = mid;</code>这一行。如果mid还是取为l + r &gt;&gt; 1，则当l仅比r小1的时候，如果check(mid)成立了，l&#x3D;mid，而此时mid还是l，就陷入了死循环了。所以必须要加上一个1</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> n, q;</span><br><span class="line"><span class="type">int</span> arr[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;q);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;arr[i]);</span><br><span class="line">    <span class="keyword">while</span> (q--)     <span class="comment">//while(q--)的写法，刚好会循环q次</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> query;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;query);</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//下面这个for循环是用来找query出现的起始位置的</span></span><br><span class="line">        <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (arr[mid] &lt; query) l = mid + <span class="number">1</span>;      <span class="comment">//因为是找起始位置，所以要注意用什么性质</span></span><br><span class="line">            <span class="comment">// 起始位置界满足的性质应该是，它左边的所有元素都严格小于query，所以这里if条件判断的</span></span><br><span class="line">            <span class="comment">// 时候用的是arr[mid] &lt; query</span></span><br><span class="line">            <span class="keyword">else</span> r = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (arr[l] != query)    <span class="comment">// 此时跳出了第一个while，说明l == r，而如果arr[l] != query</span></span><br><span class="line">        <span class="comment">// 说明第一个大于等于query的元素，起始已经大于query了，所以这个数组里就没有这个query</span></span><br><span class="line">        <span class="comment">// 故按照题目说的来输出</span></span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;-1 -1&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>        <span class="comment">//如果进入到了这个else分支，说明上面if不成立，也就是说，这个数组里确实是有</span></span><br><span class="line">        <span class="comment">// query元素的。则可以进一步的来判断query出现的终止位置</span></span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; l &lt;&lt; <span class="string">&#x27; &#x27;</span>;   <span class="comment">// 先输出一下上面已经求出的起始位置</span></span><br><span class="line">            r = n - <span class="number">1</span>;          <span class="comment">// 这里当然可以重新l = 0, r = n - 1；但，既然这里是求终止位置，</span></span><br><span class="line">            <span class="comment">// 终止位置肯定是大于等于起始位置，所以其实没必要把l重新初始化</span></span><br><span class="line">            <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (arr[mid] &gt; query) r = mid - <span class="number">1</span>;  <span class="comment">// 这里因为是在找终止位置，而终止位置的性质</span></span><br><span class="line">                <span class="comment">// 是，它右边的元素一定严格大于query，故此处的条件是arr[mid] &gt; query</span></span><br><span class="line">                <span class="comment">// 而根据模板，当l = mid时，上面求mid的时候需要+1，以免出现死循环</span></span><br><span class="line">                <span class="keyword">else</span> l = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; r &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-2-2-浮点数二分"><a href="#3-2-2-浮点数二分" class="headerlink" title="3.2.2.浮点数二分"></a>3.2.2.浮点数二分</h3><h4 id="这种情况，我们一般要做的就是在一个区间里，去逼近某个数，这个数可能不能直接求出来。例如，求某个数的三次方根。这个就简单多了，不需要考虑什么边界情况。只需要保证单调性即可。还是以上面提到的三次方根为例。开三次方的函数显然是单调递增的。直接看代码就能懂了"><a href="#这种情况，我们一般要做的就是在一个区间里，去逼近某个数，这个数可能不能直接求出来。例如，求某个数的三次方根。这个就简单多了，不需要考虑什么边界情况。只需要保证单调性即可。还是以上面提到的三次方根为例。开三次方的函数显然是单调递增的。直接看代码就能懂了" class="headerlink" title="这种情况，我们一般要做的就是在一个区间里，去逼近某个数，这个数可能不能直接求出来。例如，求某个数的三次方根。这个就简单多了，不需要考虑什么边界情况。只需要保证单调性即可。还是以上面提到的三次方根为例。开三次方的函数显然是单调递增的。直接看代码就能懂了"></a>这种情况，我们一般要做的就是在一个区间里，去逼近某个数，这个数可能不能直接求出来。例如，求某个数的三次方根。这个就简单多了，不需要考虑什么边界情况。只需要保证单调性即可。还是以上面提到的三次方根为例。开三次方的函数显然是单调递增的。直接看代码就能懂了</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="type">double</span> l = <span class="number">-10000</span>, r = <span class="number">10000</span>;</span><br><span class="line">    <span class="keyword">while</span> (r - l &gt; <span class="number">1e-8</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">double</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (mid * mid * mid &lt; n) l = mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (mid * mid * mid &gt; n) r = mid;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; fixed &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">6</span>);</span><br><span class="line">            cout &lt;&lt; mid;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; fixed &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">6</span>);</span><br><span class="line">    cout &lt;&lt; r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="built_in">float</span>(<span class="built_in">input</span>())</span><br><span class="line"><span class="comment"># 这里初始化的时候，如果不带.0，就默认l和r都是整数，于是后面while循环中计算mid的时候都是整数的除法，相当于</span></span><br><span class="line"><span class="comment"># (l + r) // 2    这会导致，后面当l和r只差1的时候，(l + r) // 2一直是l，所以l，r区间一直不变，且长度一直为</span></span><br><span class="line"><span class="comment"># 1，而我们跳出while循环的条件是区间长度小于等于1e-8，所以一直满足不了这个条件，死循环了，故TLE</span></span><br><span class="line"><span class="comment"># 带上.0以后，就默认l和r都是浮点数，后面的除2就是正常的除2，能得到精确的小数结果，所以没问题了</span></span><br><span class="line">l, r = -<span class="number">10000.0</span>, <span class="number">10000.0</span></span><br><span class="line"><span class="keyword">while</span> r - l &gt; <span class="number">1e-8</span>:</span><br><span class="line">    mid = (l + r) / <span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> mid ** <span class="number">3</span> &gt; n:</span><br><span class="line">        r = mid</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        l = mid</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&#123;:.6f&#125;&quot;</span>.<span class="built_in">format</span>(l))</span><br></pre></td></tr></table></figure>
<h4 id="顺带说明一下python中的-format-f-string的用法。-format是python的一种字符串格式化的一种语法（也是比较老的一种，先于f-string出现）"><a href="#顺带说明一下python中的-format-f-string的用法。-format是python的一种字符串格式化的一种语法（也是比较老的一种，先于f-string出现）" class="headerlink" title="顺带说明一下python中的.format&#x2F;f-string的用法。.format是python的一种字符串格式化的一种语法（也是比较老的一种，先于f-string出现）"></a>顺带说明一下python中的.format&#x2F;f-string的用法。.format是python的一种字符串格式化的一种语法（也是比较老的一种，先于f-string出现）</h4><h4 id="以上面用到的-6f-为例。-是占位符，-是一个起始说明符，它后面就是我们期望的格式。而落回到这里，”-6f”就是我们希望的格式，”-”是精度指示符，”6”代表要保留的小数位数，所以这里”-6f”就代表我们期望的格式是保留6位小数"><a href="#以上面用到的-6f-为例。-是占位符，-是一个起始说明符，它后面就是我们期望的格式。而落回到这里，”-6f”就是我们希望的格式，”-”是精度指示符，”6”代表要保留的小数位数，所以这里”-6f”就代表我们期望的格式是保留6位小数" class="headerlink" title="以上面用到的{:.6f}为例。{}是占位符，:是一个起始说明符，它后面就是我们期望的格式。而落回到这里，”.6f”就是我们希望的格式，”.”是精度指示符，”6”代表要保留的小数位数，所以这里”.6f”就代表我们期望的格式是保留6位小数"></a>以上面用到的{:.6f}为例。{}是占位符，:是一个起始说明符，它后面就是我们期望的格式。而落回到这里，”.6f”就是我们希望的格式，”.”是精度指示符，”6”代表要保留的小数位数，所以这里”.6f”就代表我们期望的格式是保留6位小数</h4><h4 id="至于f-string，它是在python3-6之后才出现的，也是用于控制字符串格式的。它相比于-format，特点就是更加简洁。在此处，如果我们还是希望输出保留6位小数，用f-string，则可以这样表示：f-l-6f-。这里我们直接把要输出的变量l放到-里面，至于”-”和”-6f”的用法和功能，则是和上面一样"><a href="#至于f-string，它是在python3-6之后才出现的，也是用于控制字符串格式的。它相比于-format，特点就是更加简洁。在此处，如果我们还是希望输出保留6位小数，用f-string，则可以这样表示：f-l-6f-。这里我们直接把要输出的变量l放到-里面，至于”-”和”-6f”的用法和功能，则是和上面一样" class="headerlink" title="至于f-string，它是在python3.6之后才出现的，也是用于控制字符串格式的。它相比于.format，特点就是更加简洁。在此处，如果我们还是希望输出保留6位小数，用f-string，则可以这样表示：f{l:.6f}。这里我们直接把要输出的变量l放到{}里面，至于”:”和”.6f”的用法和功能，则是和上面一样"></a>至于f-string，它是在python3.6之后才出现的，也是用于控制字符串格式的。它相比于.format，特点就是更加简洁。在此处，如果我们还是希望输出保留6位小数，用f-string，则可以这样表示：f{l:.6f}。这里我们直接把要输出的变量l放到{}里面，至于”:”和”.6f”的用法和功能，则是和上面一样</h4>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://gitookie.github.io/gitookie/2025/02/03/chap1.%E7%AC%AC%E4%B8%80%E8%AE%B2%20%20%E5%BF%AB%E6%8E%92%E5%92%8C%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E5%92%8C%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/" data-id="cm6pde2ho0000vgur3okl609q" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/gitookie/2025/02/03/chap1.%E7%AC%AC%E4%BA%8C%E8%AE%B2%20%E9%AB%98%E7%B2%BE%E5%BA%A6/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          (no title)
        
      </div>
    </a>
  
  
    <a href="/gitookie/2025/02/03/hello-world/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Hello World</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/gitookie/archives/2025/02/">February 2025</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/gitookie/2025/02/03/chap1.%E7%AC%AC%E4%BA%8C%E8%AE%B2%20%E9%AB%98%E7%B2%BE%E5%BA%A6/">(no title)</a>
          </li>
        
          <li>
            <a href="/gitookie/2025/02/03/chap1.%E7%AC%AC%E4%B8%80%E8%AE%B2%20%20%E5%BF%AB%E6%8E%92%E5%92%8C%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E5%92%8C%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/">(no title)</a>
          </li>
        
          <li>
            <a href="/gitookie/2025/02/03/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/gitookie/" class="mobile-nav-link">Home</a>
  
    <a href="/gitookie/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/gitookie/js/jquery-3.6.4.min.js"></script>



  
<script src="/gitookie/fancybox/jquery.fancybox.min.js"></script>




<script src="/gitookie/js/script.js"></script>





  </div>
</body>
</html>